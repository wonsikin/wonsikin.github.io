<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WonSikin&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-12-09T08:57:17.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>WonSikin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NGINX安全性配置</title>
    <link href="http://yoursite.com/2016/12/08/NGINX%E5%AE%89%E5%85%A8%E6%80%A7%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2016/12/08/NGINX安全性配置/</id>
    <published>2016-12-08T09:11:47.000Z</published>
    <updated>2016-12-09T08:57:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍一些SSL安全性的配置，以此提升网站的安全等级。先给出本博客的SSL配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen                      443 ssl;</div><div class="line">    server_name                 www.wonsikin.com;</div><div class="line">    server_tokens               off;</div><div class="line">	</div><div class="line">    # 中间证书 + 站点证书</div><div class="line">    ssl_certificate             /home/webapp/ssl/wonsikin.chained.crt;</div><div class="line">    # 生成证书的密钥</div><div class="line">    ssl_certificate_key         /home/webapp/ssl/wonsikin.com.key;</div><div class="line">    </div><div class="line">    ssl_ciphers                 EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;</div><div class="line">    ssl_prefer_server_ciphers   on;</div><div class="line"></div><div class="line">    ssl_protocols               TLSv1 TLSv1.1 TLSv1.2;</div><div class="line"></div><div class="line">    ssl_session_cache           shared:SSL:10m;</div><div class="line">    ssl_session_timeout         60m;</div><div class="line"></div><div class="line">    ssl_stapling                on;</div><div class="line">    ssl_stapling_verify         on;</div><div class="line">    resolver                    8.8.8.8 8.8.4.4 valid=300s;</div><div class="line">    resolver_timeout            5s;</div><div class="line"></div><div class="line">    access_log                  logs/wonsikin.log  main;</div><div class="line">    </div><div class="line">    if ($request_method !~ ^(GET|HEAD|POST|OPTIONS|DELETE|PUT)$ ) &#123;</div><div class="line">        return           		444;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    location / &#123;</div><div class="line">        alias                   /home/webapp/wonsikin/;</div><div class="line">        index                   index.html;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="掩藏NGINX版本号"><a href="#掩藏NGINX版本号" class="headerlink" title="掩藏NGINX版本号"></a>掩藏NGINX版本号</h3><p>隐藏NGINX版本号可以增加黑客利用该版本已知的漏洞来攻击服务器的代价。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">server_tokens   off;</div></pre></td></tr></table></figure></p>
<h3 id="禁用不安全的HTTP方法"><a href="#禁用不安全的HTTP方法" class="headerlink" title="禁用不安全的HTTP方法"></a>禁用不安全的HTTP方法</h3><p>TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方法。但是一般很少用到，而且容易引发XST（Cross-Site Tracing，跨站追踪）攻击。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if ($request_method !~ ^(GET|HEAD|POST|OPTIONS|DELETE|PUT)$ ) &#123;</div><div class="line">  return        444;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上配置表明服务器会对GET、HEAD、POST、OPTIONS、DELETE、PUT返回444的状态码，444 是 Nginx 定义的响应状态码，会立即断开连接，没有响应正文。</p>
<h3 id="openssl"><a href="#openssl" class="headerlink" title="openssl"></a>openssl</h3><p>心血漏洞（Heartbleed） 是一个于2014年4月公布的 OpenSSL 加密库的漏洞，它是一个被广泛使用的传输层安全（TLS）协议的实现。无论是服务器端还是客户端在 TLS 中使用了有缺陷的 OpenSSL，都可以被利用该缺陷。</p>
<p>升级服务器安装的<code>openssl</code> 到最新版本可以避免这个漏洞。</p>
<p><strong>注意</strong>：启用最新版本的openssl，需要把 NGINX 关闭，然后再开启，不是简单的 reload 就可以的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">./sbin/nginx -s stop</div><div class="line">./sbin/nginx</div><div class="line"></div><div class="line"># 执行以下命令是不能启用最新版本的openssl的</div><div class="line">./sbin/nginx -s reload</div></pre></td></tr></table></figure></p>
<h3 id="加密套件"><a href="#加密套件" class="headerlink" title="加密套件"></a>加密套件</h3><p>设置更健壮的加密套件（cipher suite）来尽可能启用前向安全性（Forward Secrecy）。前向安全性（Forward Secrecy）用于在长期密钥被破解时确保会话密钥的完整性。PFS（完备的前向安全性）是指强制在每个/每次会话中推导新的密钥。<br>如何设置可以参考<a href="https://cipherli.st/" target="_blank" rel="external">Cipherli.st - Strong Ciphers for Apache, nginx and Lighttpd</a>这个网址。<br>推荐的<code>ssl_ciphers</code> 设置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssl_ciphers                 EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;</div></pre></td></tr></table></figure></p>
<p>同时，确保也添加了如下的配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ssl_prefer_server_ciphers   on;</div><div class="line">ssl_session_cache           shared:SSL:10m;</div><div class="line">ssl_session_timeout         60m;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>TLS 会话恢复的目的是为了简化 TLS 握手，有两种方案：Session Cache 和 Session Ticket。他们都是将之前握手的 Session 存起来供后续连接使用，所不同是 Cache 存在服务端，占用服务端资源；Ticket 存在客户端，不占用服务端资源。另外目前主流浏览器都支持 Session Cache，而 Session Ticket 的支持度一般。</p>
</blockquote>
<p>TLS握手过程中选择一个加密算法时，一般使用客户端的首选算法。如果设置了上述配置，则会替代地使用服务器端的首选算法。</p>
<h3 id="SSL协议"><a href="#SSL协议" class="headerlink" title="SSL协议"></a>SSL协议</h3><p>SSLv2 已被证实是不安全的，同时因为 TLS 1.0 在遭受到降级攻击时，会允许攻击者强制连接使用 SSLv3，从而禁用了前向安全性（forward secrecy）。所以<code>ssl_protocols</code> 的配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssl_protocols               TLSv1 TLSv1.1 TLSv1.2;</div></pre></td></tr></table></figure></p>
<h3 id="OCSP-Stapling"><a href="#OCSP-Stapling" class="headerlink" title="OCSP Stapling"></a>OCSP Stapling</h3><p>当客户端连接到服务器的时候，客户端会使用 <code>Certificate Revocation List（CRL）</code> 或者 <code>Online Certificate Status Protocol（OCSP）记录</code>校验服务器证书的合法性。<code>CRL</code> 的问题是证书吊销列表已经变得很大，下载太费时。</p>
<p><code>OCSP</code>相比之下就比较轻量级，因为一次只检索一条记录。但是副作用就是客户端连接服务器的时候，<code>OCSP</code> 请求必须发送到第三方<code>OCSP响应器（OCSP responder）</code>，这就可能会存在请求失败的隐患。实际上，证书颁发机构运转的OCSP响应器经常是不可靠的，以至于当浏览器没有及时收到响应的时候就会静默失败。</p>
<p>解决方法是在TLS握手的时候允许服务器发送缓存的<code>OCSP</code>记录，以此绕过OCSP响应器。这种机制就叫做<code>OCSP Stapling</code>，它省掉了客户端和OCSP响应器之间的一个交互。大部分服务器会缓存OCSP响应将近48小时，然后在快过期的时候会连接到OCSP响应器检索最新的OCSP纪录。</p>
<p>在NGINX中增加一下配置来启用<code>OCSP Stapling</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ssl_stapling                on;</div><div class="line">ssl_stapling_verify         on;</div><div class="line">resolver                    8.8.8.8 8.8.4.4 valid=300s;</div><div class="line">resolver_timeout            5s;</div></pre></td></tr></table></figure></p>
<p>要使<code>OCSP Stapling</code>正常工作，需要知道服务器证书颁布者的证书。如果在<code>ssl_certificate</code>文件中没有包含中级证书（ intermediate certificates），需要在<code>ssl_trusted_certificate</code>文件中服务器证书颁布者的证书。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssl_trusted_certificate	    /etc/ssl/certs/domain.chain.stapling.pem;</div></pre></td></tr></table></figure></p>
<p>可以使用以下命令测试<code>OCSP Stapling</code>是否正常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl s_client -connect example.org:443 -tls1 -tlsextdebug -status</div></pre></td></tr></table></figure></p>
<p>以上的配置就能够保证你的网站在 <a href="https://www.ssllabs.com/ssltest/analyze.html" target="_blank" rel="external">SSL Server Test (Powered by Qualys SSL Labs)</a>中的测试得到<strong>A</strong>的评分。</p>
<p><img src="https://ooo.0o0.ooo/2016/12/08/5849188fde57e.png" alt="SSL Labs评分"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.open-open.com/lib/view/open1430794673710.html" target="_blank" rel="external">增强 nginx 的 SSL 安全性  - OPEN 开发经验库</a></li>
<li><a href="https://raymii.org/s/tutorials/OCSP_Stapling_on_nginx.html" target="_blank" rel="external">OCSP Stapling on nginx - Raymii.org</a></li>
<li><a href="https://imququ.com/post/my-nginx-conf.html" target="_blank" rel="external">本博客 Nginx 配置之完整篇 | JerryQu 的小站</a></li>
<li><a href="https://imququ.com/post/my-nginx-conf-for-security.html" target="_blank" rel="external">本博客 Nginx 配置之安全篇 | JerryQu 的小站</a></li>
<li><a href="https://imququ.com/post/why-can-not-turn-on-ocsp-stapling.html" target="_blank" rel="external">从无法开启 OCSP Stapling 说起 | JerryQu 的小站</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍一些SSL安全性的配置，以此提升网站的安全等级。先给出本博客的SSL配置：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;server &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    listen                      443 ssl;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    server_name                 www.wonsikin.com;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    server_tokens               off;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    # 中间证书 + 站点证书&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ssl_certificate             /home/webapp/ssl/wonsikin.chained.crt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    # 生成证书的密钥&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ssl_certificate_key         /home/webapp/ssl/wonsikin.com.key;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ssl_ciphers                 EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ssl_prefer_server_ciphers   on;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ssl_protocols               TLSv1 TLSv1.1 TLSv1.2;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ssl_session_cache           shared:SSL:10m;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ssl_session_timeout         60m;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ssl_stapling                on;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ssl_stapling_verify         on;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    resolver                    8.8.8.8 8.8.4.4 valid=300s;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    resolver_timeout            5s;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    access_log                  logs/wonsikin.log  main;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    if ($request_method !~ ^(GET|HEAD|POST|OPTIONS|DELETE|PUT)$ ) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        return           		444;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    location / &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        alias                   /home/webapp/wonsikin/;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        index                   index.html;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="NGINX" scheme="http://yoursite.com/tags/NGINX/"/>
    
      <category term="WEB安全" scheme="http://yoursite.com/tags/WEB%E5%AE%89%E5%85%A8/"/>
    
      <category term="HTTPS" scheme="http://yoursite.com/tags/HTTPS/"/>
    
      <category term="SSL" scheme="http://yoursite.com/tags/SSL/"/>
    
      <category term="TLS" scheme="http://yoursite.com/tags/TLS/"/>
    
  </entry>
  
  <entry>
    <title>使用树莓派打造翻墙路由器：从开始到放弃</title>
    <link href="http://yoursite.com/2016/12/02/%E4%BD%BF%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E6%89%93%E9%80%A0%E7%BF%BB%E5%A2%99%E8%B7%AF%E7%94%B1%E5%99%A8%EF%BC%9A%E4%BB%8E%E5%BC%80%E5%A7%8B%E5%88%B0%E6%94%BE%E5%BC%83/"/>
    <id>http://yoursite.com/2016/12/02/使用树莓派打造翻墙路由器：从开始到放弃/</id>
    <published>2016-12-02T10:00:10.000Z</published>
    <updated>2016-12-02T09:02:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前买了一块树莓派一直闲置着，本着折腾不浪费的精神，遂决定把它改造成一个可以科学上网的无线路由器。</p>
<a id="more"></a>
<p>准备清单：</p>
<ol>
<li>树莓派一枚</li>
<li>无线网卡一枚，型号：<code>EP-N8508GS</code>，芯片是 <code>Realtek RTL8188CUS</code></li>
<li>micro SD 卡一枚，至少4G</li>
<li>树莓派官方系统<code>Raspbian</code>镜像</li>
<li>电脑若干</li>
<li>USB电源线和网线各一条</li>
</ol>
<p>这里需要注意的是我使用的无线网卡，芯片因为是 <code>Realtek RTL8188CUS</code> ，需要特殊处理，所以一开始花费了好多时间处理处理。为什么使用该芯片呢？首先，便宜；其次，很早以前就买好了。当然如果你是土豪，类似下面这位，你可以买一个兼容的芯片。</p>
<h3 id="刷机"><a href="#刷机" class="headerlink" title="刷机"></a>刷机</h3><p>刷机使用的是Windows电脑，Linux电脑也是能够刷机的，之前刷<code>OpenWRT</code>系统的时候使用过，Mac系统还没试过。</p>
<p>从树莓派<a href="https://www.raspberrypi.org/downloads/raspbian/" target="_blank" rel="external">官方网站</a>下载最新版本的 <code>Raspbian</code> 系统镜像，这里用的版本是 <code>RASPBIAN JESSIE</code> 完全版。</p>
<p>电脑上下载 <code>Win32DiskImager</code> ，用来把镜像写入SD卡中。</p>
<h3 id="Raspbian系统配置"><a href="#Raspbian系统配置" class="headerlink" title="Raspbian系统配置"></a>Raspbian系统配置</h3><p><img src="/images/Raspi-config.png" alt="raspi-confing"></p>
<p>在终端中输入命令，会弹出上图的配置窗口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo raspi-config</div></pre></td></tr></table></figure>
<p>主要配置以下几项：</p>
<ul>
<li>1 Expand Filesystem</li>
<li>2 Change User Password</li>
<li>5 Internationalisation Options<ul>
<li>I1 Change Locale</li>
<li>I2 Change Timezone</li>
<li>I3 Change Keyboard Layout</li>
<li>I4 Change Wi-fi Country</li>
</ul>
</li>
<li>9 Advanced Options<ul>
<li>A3 Memory Split：如果只是当做路由器使用，可以把GPU的内存改小点。我这里的设置是32.</li>
<li>A0 Update:这一步需要系统联网</li>
</ul>
</li>
</ul>
<p>重启电脑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo shutdown -r now</div></pre></td></tr></table></figure>
<h3 id="安装并配置-hostapd"><a href="#安装并配置-hostapd" class="headerlink" title="安装并配置 hostapd"></a>安装并配置 hostapd</h3><p><code>hostapd</code> 可以让无线网卡变成信号发射器，如果你的芯片是官方支持的，可以直接从软件源中安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install hostapd</div></pre></td></tr></table></figure>
<p>我这边使用的无线网卡的芯片是官方不支持的，所以得自己安装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">wget https://codeload.github.com/jenssegers/RTL8188-hostapd/zip/v2.0</div><div class="line"></div><div class="line">tar -zxvf v2.0.tar.gz</div><div class="line"></div><div class="line">cd RTL8188-hostapd-2.0/hostapd</div><div class="line"></div><div class="line">sudo make</div><div class="line"></div><div class="line">sudo make install</div><div class="line"></div><div class="line"># 启动命令</div><div class="line">sudo service hostapd restart</div></pre></td></tr></table></figure>
<p>打开 <code>hostapd</code> 的配置文件，配置 <code>ssid</code>（Wi-fi名称）、<code>wpa_passphrase</code>（Wi-fi密码）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo nano /etc/hostapd/hostapd.conf</div></pre></td></tr></table></figure>
<p>以下是我的配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"># Basic configuration</div><div class="line"></div><div class="line">interface=wlan0</div><div class="line">ssid=CIL-F2E</div><div class="line">channel=1</div><div class="line">#bridge=br0</div><div class="line"></div><div class="line"># WPA and WPA2 configuration</div><div class="line"></div><div class="line">macaddr_acl=0</div><div class="line">auth_algs=1</div><div class="line">ignore_broadcast_ssid=0</div><div class="line">wpa=3</div><div class="line">wpa_passphrase=*********</div><div class="line">wpa_key_mgmt=WPA-PSK</div><div class="line">wpa_pairwise=TKIP</div><div class="line">rsn_pairwise=CCMP</div><div class="line"></div><div class="line"># Hardware configuration</div><div class="line"></div><div class="line">driver=rtl871xdrv</div><div class="line">ieee80211n=1</div><div class="line">hw_mode=g</div><div class="line">device_name=RTL8192CU</div><div class="line">manufacturer=Realtek</div></pre></td></tr></table></figure>
<p>重启 <code>hostapd</code> 服务，并设置开机启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo service hostapd restart</div><div class="line">sudo update-rc.d hostapd defaults</div></pre></td></tr></table></figure>
<h3 id="安装并配置-udhcpd"><a href="#安装并配置-udhcpd" class="headerlink" title="安装并配置 udhcpd"></a>安装并配置 udhcpd</h3><p><code>udhcpd</code> 可以让链接到Wi-fi设备的客户端通过<code>DHCP</code>获取到IP地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install udhcpd</div></pre></td></tr></table></figure>
<p>修改 <code>udhcpd</code> 的配置文件 <code>/etc/udhcpd.conf</code> ：</p>
<ul>
<li>start 和 end： DHCP 分配的 IP 段的起始和结束 IP</li>
<li>interface：修改成上一步配置的interface</li>
<li>opt dns： DNS</li>
<li>option subnet：子网掩码</li>
<li>opt router：路由器 IP</li>
</ul>
<p>以下是我的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"># Sample udhcpd configuration file (/etc/udhcpd.conf)</div><div class="line"></div><div class="line"># The start and end of the IP lease block</div><div class="line">start		192.168.37.1	#default: 192.168.0.20</div><div class="line">end		192.168.37.254	#default: 192.168.0.254</div><div class="line"></div><div class="line"># The interface that udhcpd will use</div><div class="line">interface	wlan0		#default: eth0</div><div class="line"></div><div class="line">#Examles</div><div class="line">opt	dns	114.114.114.114</div><div class="line">option	subnet	255.255.255.0</div><div class="line">opt	router	192.168.37.1</div><div class="line">#opt	wins	192.168.37.10</div><div class="line">option	dns	8.8.8.8	# appened to above DNS servers for a total of 3</div><div class="line">#option	domain	local</div><div class="line">option	lease	864000		# 10 days of seconds</div></pre></td></tr></table></figure>
<p>接着修改 <code>/etc/default/udhcpd</code>，注释掉 <code>DHCPD_ENABLED=&quot;no&quot;</code> 这一行。</p>
<p>重启 <code>udhcpd</code> 服务，并设置开机启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo service udhcpd restart</div><div class="line">sudo update-rc.d udhcpd defaults</div></pre></td></tr></table></figure>
<h3 id="配置-iptables-和网络接口"><a href="#配置-iptables-和网络接口" class="headerlink" title="配置 iptables 和网络接口"></a>配置 iptables 和网络接口</h3><p>打开网络接口配置文件 <code>/etc/network/interfaces</code> ，设置 <code>wlan0</code> 为静态IP:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">auto lo</div><div class="line">iface lo inet loopback</div><div class="line"></div><div class="line">iface eth0 inet dhcp</div><div class="line"></div><div class="line">allow-hotplug wlan0</div><div class="line"></div><div class="line">iface wlan0 inet static</div><div class="line">    address 192.168.37.1</div><div class="line">    netmask 255.255.255.0</div><div class="line">   # wpa-conf /etc/wpa_supplicant/wpa_supplicant.conf</div></pre></td></tr></table></figure>
<p>注意上面的 <code>wlan0</code> 配置，请勿加上 <code>gateway 192.168.x.x</code> 的配置，否则会导致其它设备连接得上树莓派，但是DNS解析不了的问题。</p>
<p>使生效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo ifdown wlan0</div><div class="line">sudo ifup wlan0</div></pre></td></tr></table></figure></p>
<p>接着配置 <code>iptables</code> 。修改 <code>/etc/sysctl.conf</code> ，打开内核IP转发，在末尾添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">net.ipv4.ip_forward=1</div></pre></td></tr></table></figure>
<p>然后，添加 <code>iptables</code> 规则，将 <code>wlan0</code> 的包通过 <code>eth0</code> 转发，在命令行中输入下列命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</div><div class="line">sudo iptables -A FORWARD -i eth0 -o wlan0 -m state --state RELATED,ESTABLISHED -j ACCEPT</div><div class="line">sudo iptables -A FORWARD -i wlan0 -o eth0 -j ACCEPT</div></pre></td></tr></table></figure>
<p>由于 <code>iptables</code> 设置重启后将消失，常用的方法是先保存下来，然后在启动的时候加载规则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">＃ 备份 iptables规则</div><div class="line">sudo sh -c &quot;iptables-save &gt; /etc/iptables.ipv4.nat&quot;</div></pre></td></tr></table></figure>
<p>编辑 <code>/etc/network/interfaces</code>，添加下面这一行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 启动的时候加载</div><div class="line">up iptables-restore &lt; /etc/iptables.ipv4.nat</div></pre></td></tr></table></figure>
<p>以上，设置Wi-fi热点的配置就完成了，重启树莓派，用其它设备连接应该就能够上网了。</p>
<h3 id="安装shadowsocks服务"><a href="#安装shadowsocks服务" class="headerlink" title="安装shadowsocks服务"></a>安装shadowsocks服务</h3><p>shadowsocks 是科学上网的一种非常有用的工具。以下内容的前提是需要有一个shadowsocks账号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#安装pip管理python包</div><div class="line">sudo apt-get install python-pip python-m2crypto</div><div class="line">#安装python版shadowsocks</div><div class="line">sudo pip install shadowsocks</div></pre></td></tr></table></figure>
<p>创建shadowsocks的配置文件，可以在任意目录。以下以 /etc/shadowsocks/config.json 为例。编辑如下内容</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"server"</span>: <span class="string">"58.***.**.*"</span>,</div><div class="line">    <span class="attr">"server_port"</span>: <span class="number">8390</span>,</div><div class="line">    <span class="attr">"password"</span>: <span class="string">"********"</span>,</div><div class="line">    <span class="attr">"method"</span>: <span class="string">"aes-256-cfb"</span>,</div><div class="line">    <span class="attr">"local_address"</span>: <span class="string">"192.168.37.1"</span>,</div><div class="line">    <span class="attr">"local_port"</span>: <span class="number">1080</span>,</div><div class="line">    <span class="attr">"timeout"</span>: <span class="number">60</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>设置开机启动。编辑 /etc/rc.local。在exit前添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/local/bin/sslocal -c /etc/shadowsocks/config.json &amp;</div></pre></td></tr></table></figure>
<h3 id="放弃"><a href="#放弃" class="headerlink" title="放弃"></a>放弃</h3><p>改造后的树莓派路由器服务并不稳定，经常会出现连接不了网络，需要重新启动才能继续上网。<br>另外本来打算将改造后的路由器放在公司使用，但是因为公司网络策略升级，不允许随意搭建私人路由器，所以也就放弃继续改造下去。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://www.cnblogs.com/yondy/archive/2013/04/23/3033404.html" target="_blank" rel="external">树莓派raspbian安装配置</a></li>
<li><a href="http://liberize.me/tech/turn-raspberry-pi-into-a-router.html" target="_blank" rel="external">将树莓派打造成无线路由器</a></li>
<li><a href="https://www.jenssegers.be/43/realtek-rtl8188-based-access-point-on-raspberry-pi" target="_blank" rel="external">Realtek RTL8188 based access point on Raspberry Pi</a></li>
<li><a href="https://lttt.blog.ustc.edu.cn/2015/06/11/shadowsocks%E6%A0%91%E8%8E%93%E6%B4%BE%E7%BF%BB%E5%A2%99.html" target="_blank" rel="external">shadowsocks树莓派翻墙</a></li>
<li><a href="http://blog.anthonywong.net/2015/07/12/deploy-shadowsocks-chinadns-redsocks-raspberry-pi/" target="_blank" rel="external">deploy-shadowsocks-chinadns-redsocks-raspberry-pi</a></li>
<li><a href="http://blog.anthonywong.net/2016/01/18/securing-dns-traffic-in-china/" target="_blank" rel="external">securing-dns-traffic-in-china</a></li>
<li><a href="http://blog.creke.net/722.html" target="_blank" rel="external">SSH隧道与端口转发及内网穿透</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前买了一块树莓派一直闲置着，本着折腾不浪费的精神，遂决定把它改造成一个可以科学上网的无线路由器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="树莓派" scheme="http://yoursite.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
      <category term="IoT" scheme="http://yoursite.com/tags/IoT/"/>
    
  </entry>
  
  <entry>
    <title>如何传送时间参数到服务端</title>
    <link href="http://yoursite.com/2016/06/07/%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%81%E6%97%B6%E9%97%B4%E5%8F%82%E6%95%B0%E5%88%B0%E5%90%8E%E5%8F%B0/"/>
    <id>http://yoursite.com/2016/06/07/如何传送时间参数到后台/</id>
    <published>2016-06-07T10:47:32.000Z</published>
    <updated>2016-07-03T12:29:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我所在的项目SM负责扫码支付的处理，所有的数据都存储在 <code>MongoDB</code> 中，因为这段时间的业务发展，数据库越来越大，同时也感觉到了查询的速度越来越慢。<br>后端同事加班加点变得频繁，使用各种方法来给解决 <code>MongoDB</code> 查询慢的问题，能加索引的加索引，能优化查询语句的优化。<br>另外公司也请来了一位 <code>MongoDB</code> 的大牛来讲解一些 <code>MongoDB</code> 的最佳体验。<br>比如我接下来要讲的：时间数据的存储。</p>
<a id="more"></a>
<h3 id="服务端的时间类型设置"><a href="#服务端的时间类型设置" class="headerlink" title="服务端的时间类型设置"></a>服务端的时间类型设置</h3><p>SM项目是我和另外两个前同事一起搭建起来的，当初的技术选型（Polymer + Golang +  <code>MongoDB</code> ）对我们来说都是第一次在生产项目上的应用，所以有一些不规范的使用。<br>比如在时间数据的存储上，我们直接在数据库存储了类似 “YYYY-MM-DD hh:mm:ss” 的字符串。经过大牛的点拨后，我们意识到这是一个非常糟糕的处理方法。</p>
<p>正好最近有个新需求，需要给一个结构体增加时间方面的字段。于是我这么设计了结构体的属性：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Agent <span class="keyword">struct</span> &#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">    ContractStartDate *time.Time <span class="string">`bson:"contractStartDate,omitempty" json:"contractStartDate,string"`</span>  <span class="comment">// 合同开始日期</span></div><div class="line">    ContractEndDate   *time.Time <span class="string">`bson:"contractEndDate,omitempty" json:"contractEndDate,string"`</span>      <span class="comment">// 合同结束日期</span></div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意这里的时间的类型必须定义为指针，所择会出现前端传送空的时间到服务器的时候，服务器自动把时间解析成耶稣诞生的时点了。</p>
<p>存进<code>MongoDB</code>数据库的时间如下所示，自带时区属性，便于项目国际化拓展。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    ...</div><div class="line">    &quot;contractStartDate&quot; : ISODate(&quot;2014-05-01T00:00:00.000+0800&quot;),</div><div class="line">    &quot;contractEndDate&quot; : ISODate(&quot;2017-05-31T00:00:00.000+0800&quot;),</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="前端时间传送到服务端的选择"><a href="#前端时间传送到服务端的选择" class="headerlink" title="前端时间传送到服务端的选择"></a>前端时间传送到服务端的选择</h3><p>如何将前端的时间参数发送给服务端，并且服务端正确解析呢？</p>
<p>如果是POST请求，并且参数都是放到body里面的话，此时的数据一般是JSON字符串。<br>JavaScript中的Date类型的数据转成JSON字符串的形式如下。<br>因为都是符合ISO标准的字符串，服务端是能够正确解析的。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  ...</div><div class="line">  "contractStartDate":"2016-05-31T16:00:00.000Z",</div><div class="line">  "contractEndDate":"2016-06-29T16:00:00.000Z",</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果是GET请求，并且时间参数放在query后面呢？这时候就没有像上面那么简单了，下面这两张图是分别在windows和mac平台上的谷歌浏览器中发起的请求。<br>可以看到，在两个平台上，JavaScript中的Date对象作为query参数是不一样的，那么问题来了，挖…不，该怎么破？<br>我这边的建议是使用一些操作时间的类库，比如 <a href="http://momentjs.com" target="_blank" rel="external">momentjs</a>。</p>
<h6 id="windows下Chrome浏览器"><a href="#windows下Chrome浏览器" class="headerlink" title="windows下Chrome浏览器"></a>windows下Chrome浏览器</h6><p><img src="http://ww4.sinaimg.cn/large/4da583a7gw1f5as4mxu7fj21bw0fuaeu.jpg" alt="windows下Chrome浏览器"></p>
<h6 id="Mac下Chrome浏览器"><a href="#Mac下Chrome浏览器" class="headerlink" title="Mac下Chrome浏览器"></a>Mac下Chrome浏览器</h6><p><img src="http://ww1.sinaimg.cn/large/4da583a7gw1f5as4mjs81j21kw0dun10.jpg" alt="Mac下Chrome浏览器"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;我所在的项目SM负责扫码支付的处理，所有的数据都存储在 &lt;code&gt;MongoDB&lt;/code&gt; 中，因为这段时间的业务发展，数据库越来越大，同时也感觉到了查询的速度越来越慢。&lt;br&gt;后端同事加班加点变得频繁，使用各种方法来给解决 &lt;code&gt;MongoDB&lt;/code&gt; 查询慢的问题，能加索引的加索引，能优化查询语句的优化。&lt;br&gt;另外公司也请来了一位 &lt;code&gt;MongoDB&lt;/code&gt; 的大牛来讲解一些 &lt;code&gt;MongoDB&lt;/code&gt; 的最佳体验。&lt;br&gt;比如我接下来要讲的：时间数据的存储。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="Date" scheme="http://yoursite.com/tags/Date/"/>
    
      <category term="Chrome" scheme="http://yoursite.com/tags/Chrome/"/>
    
      <category term="Windows" scheme="http://yoursite.com/tags/Windows/"/>
    
      <category term="OS X" scheme="http://yoursite.com/tags/OS-X/"/>
    
      <category term="moment.js" scheme="http://yoursite.com/tags/moment-js/"/>
    
  </entry>
  
  <entry>
    <title>VS Code 搭建 Go 开发IDE</title>
    <link href="http://yoursite.com/2016/06/06/VS-Code-%E6%90%AD%E5%BB%BA-Go-%E5%BC%80%E5%8F%91IDE/"/>
    <id>http://yoursite.com/2016/06/06/VS-Code-搭建-Go-开发IDE/</id>
    <published>2016-06-06T03:00:45.000Z</published>
    <updated>2016-06-06T03:32:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍的是如何使用VS Code 搭建一个进行Go开发的IDE。</p>
<p><code>Note</code>: 本文的所有操作都是在 OS X系统上进行的。</p>
<h1 id="VS-Code-介绍"><a href="#VS-Code-介绍" class="headerlink" title="VS Code 介绍"></a>VS Code 介绍</h1><p>VS Code 是微软开源的一个编辑器软件。刚面世的时候侧重于 C# 和前端开发，随着版本迭代和新功能出现，特别是支持安装第三方插件，VS Code 也支持其它语言的开发。</p>
<p>​VS Code 原生支持智能提示、方法补全的语言有：JavaScript, JSON, HTML, CSS, LESS, SASS。如果装上下文提到的 Go 插件，也是能够支持 Go 语言的智能提示和方法补全。</p>
<p>VS Code 最牛逼的地方是 它和 Atom 都是基于 Electron 构建的应用，但是相比于 Atom 常被诟病的卡卡卡，VS Code 打开超大文件几乎秒开。</p>
<p>不足的地方是 VS Code 的第三方插件的丰富度不及 Atom，但是假以时日，随着更多人关注它，VS Code 的第三方插件肯定会越来越丰富。</p>
<a id="more"></a>
<h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p><a href="https://code.visualstudio.com/c?utm_expid=101350005-17.ZUysucFlStyPwU4hcu0waA.2&amp;utm_referrer=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fcustomization%2Fthemes" target="_blank" rel="external">官网地址</a></p>
<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><ul>
<li><code>⌘+⇧+P</code> / <code>F1</code> 万能键</li>
<li><code>F12</code> 跳转到声明的地方</li>
<li><code>⌘+⇧+F</code>全文搜索</li>
<li><code>⌘+P</code>快速切换文件</li>
<li>⌘+点击指定文件，将此文件在分屏栏打开</li>
<li><code>⌘+D</code>多选</li>
<li><code>⌘+E</code> 打开命令行，其他指令其实都是基于命令行的，可直接在输入框输入?来查询指令</li>
<li><code>⌃+G</code>跳转到指定行</li>
<li><code>⌃+tab</code>快速切换到上一个文件,多次按(⇧)tab可以来回选择,也可以直接点击文件顶部名称来显示历史文件列表进行切换</li>
<li>⌥+点击多处可以多光标操作<h1 id="安装-Go-插件"><a href="#安装-Go-插件" class="headerlink" title="安装 Go 插件"></a>安装 Go 插件</h1><code>vscode-go</code> 是 VS Code 编辑器上非常好用的一个 golang 插件，它包括以下特性：</li>
<li>Colorization 代码着彩色</li>
<li>Completion Lists 代码自动完成（使用gocode）</li>
<li>Snippets  代码片段</li>
<li>Quick Info 快速提示信息（使用godef）</li>
<li>Goto Definition 跳转到定义（使用godef）</li>
<li>Find References  搜索参考引用（使用go-find-references）</li>
<li>File outline 文件大纲（使用go-outline）</li>
<li>Workspace symbol search 工作区符号搜索（使用 go-symbols）</li>
<li>Rename 重命名（使用gorename）</li>
<li>Build-on-save 保存构建（使用go build和go test）</li>
<li>Format 代码格式化（使用goreturns或goimports或gofmt）</li>
<li>Add Imports  添加引用（使用 gopkgs）</li>
<li>Debugging 调试代码（使用delve）</li>
<li>这里默认你已经安装了golang环境。</li>
</ul>
<p>IDE 截图 <img src="https://camo.githubusercontent.com/1f3ca22272de5e24287295486fa29f24ef28c512/687474703a2f2f692e67697068792e636f6d2f785469546e64444856334765497936614e612e676966" alt="IDE"></p>
<p>使用快捷方式(<code>⌘+P</code>)打开命令面板，输入以下命令，然后点击回车键，VS Code就开始安装Go插件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ext install Go</div></pre></td></tr></table></figure>
<p>安装完成后，按照以下说明配置一些 Go 设置。</p>
<p>打开 <code>Preferences</code> -&gt; <code>User Settings</code>，主界面右边面板的 <code>settings.json</code> 输入以下配置：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"go.buildOnSave"</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">"go.lintOnSave"</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">"go.vetOnSave"</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">"go.buildFlags"</span>: [],</div><div class="line">  <span class="attr">"go.lintFlags"</span>: [],</div><div class="line">  <span class="attr">"go.vetFlags"</span>: [],</div><div class="line">  <span class="attr">"go.useCodeSnippetsOnFunctionSuggest"</span>: <span class="literal">false</span>,</div><div class="line">  <span class="attr">"go.formatOnSave"</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">"go.formatTool"</span>: <span class="string">"goreturns"</span>,</div><div class="line">  <span class="attr">"go.goroot"</span>: <span class="string">"/usr/local/go"</span>,</div><div class="line">  <span class="attr">"go.gopath"</span>: <span class="string">"/opt/gowork"</span>,</div><div class="line">  <span class="attr">"files.autoSave"</span>: <span class="string">"onFocusChange"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意上面的 <code>go.goroot</code> 和 <code>go.gopath</code>的值，以本季系统的 <code>GOROOT</code> 和 <code>GOPATH</code> 为准。</p>
<p><code>vscode-go</code> 依赖下面列出的工具，如果缺失某些工具的话，安装完 <code>vscode-go</code> 之后打开一个go文件，在编辑器的右下角会出现 <code>Analysis Tools Missing</code> 的警告，点击它就会自动安装缺失的工具。</p>
<ul>
<li>gocode: go get -u -v github.com/nsf/gocode</li>
<li>godef: go get -u -v github.com/rogpeppe/godef</li>
<li>golint: go get -u -v github.com/golang/lint/golint</li>
<li>go-outline: go get -u -v github.com/lukehoban/go-outline</li>
<li>goreturns: go get -u -v sourcegraph.com/sqs/goreturns</li>
<li>gorename: go get -u -v golang.org/x/tools/cmd/gorename</li>
<li>gopkgs: go get -u -v github.com/tpng/gopkgs</li>
<li>go-symbols: go get -u -v github.com/newhook/go-symbols</li>
<li>guru: go get -u -v golang.org/x/tools/cmd/guru</li>
</ul>
<p>当然也可以直接在命令行中输入以下命令安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">go get -u -v github.com/nsf/gocode</div><div class="line">go get -u -v github.com/rogpeppe/godef</div><div class="line">go get -u -v github.com/golang/lint/golint</div><div class="line">go get -u -v github.com/lukehoban/go-outline</div><div class="line">go get -u -v sourcegraph.com/sqs/goreturns</div><div class="line">go get -u -v golang.org/x/tools/cmd/gorename</div><div class="line">go get -u -v github.com/tpng/gopkgs</div><div class="line">go get -u -v github.com/newhook/go-symbols</div><div class="line">go get -u -v golang.org/x/tools/cmd/guru</div></pre></td></tr></table></figure>
<h1 id="安装-delve"><a href="#安装-delve" class="headerlink" title="安装 delve"></a>安装 delve</h1><p>delve 只支持 Go 1.5以上版本，并且 Go 1.5版本的安装步骤和 Go 1.6是不一样的，相对来说 Go 1.6版本安装比较简单。</p>
<h2 id="Go-1-6"><a href="#Go-1-6" class="headerlink" title="Go 1.6"></a>Go 1.6</h2><p>如果系统安装了 <code>HomeBrew</code>， 直接执行以下命令即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ brew install go-delve/delve/delve</div></pre></td></tr></table></figure>
<p><code>NOTE</code>: 按照此步骤安装delve，如果在稍后运行Go程序的时候出现 <code>runtime/internal/sys 找不到</code> 的错误，这是因为上一步的操作另外安装了Go环境，然后覆盖了之前的。可以执行以下命令卸载 <code>brew</code> 安装的 Go 环境：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ brew uninstall Go</div></pre></td></tr></table></figure>
<h2 id="Go-1-5"><a href="#Go-1-5" class="headerlink" title="Go 1.5"></a>Go 1.5</h2><h3 id="创建一个自签名的证书"><a href="#创建一个自签名的证书" class="headerlink" title="创建一个自签名的证书"></a>创建一个自签名的证书</h3><p>创建自签名的步骤如下</p>
<ul>
<li>打开应用 <code>Keychain Access</code> (<code>/Applications/Utilities/Keychain Access.app</code>)</li>
<li>打开菜单 <code>/Keychain Access/Certificate Assistant/Create a Certificate...</code></li>
<li>选择一个名称 (比如 <code>dlv-cert</code> ), 设置选项 <code>Identity Type</code> 为 <code>Self Signed Root</code>, 设置选项 <code>Certificate Type</code> 为 <code>Code Signing</code> 然后勾选 <code>Let me override defaults</code>。 点击 <code>Continue</code>。 你可以把 <code>Validity Period</code> 从 365天扩展到3650天。</li>
<li>连续点击多次 <code>Continue</code> 按钮知道到达 <code>Specify a Location For The Certificate</code> 面板, 然后将选项 <code>Keychain</code> 设置为 <code>System</code>。</li>
<li>如果你无法将证书以 <code>System keychain</code> 的形式存储，你可以将它创建为 <code>login keychain</code>，然后导出。接着再以 <code>System keychain</code> 的形式导入。</li>
<li>创讲完后，在左边的 <code>keychains</code> 列表选择 <code>System</code> 选项，你能看到你刚刚创建的证书。鼠标右键证书，然后选择 <code>Get Info</code>， 打开 <code>Trust</code> 项, 将 <code>Code Signing</code> 设置为 <code>Always Trust</code>。</li>
<li>Yosemite 系统需要额外的操作： keychains 列表，选择 category Keys -&gt; dlv-cert -&gt; right click -&gt; GetInfo -&gt; Access Control -&gt; 选择 <code>Allow all applications to access this item</code> -&gt; 保存变更。</li>
<li>你必须将 <code>Keychain Access</code> 应用退出，这样子才能使用到证书并且重启当前正在运行的 <code>taskgated</code> 进程。你可以选择重启你的电脑。</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li>创建目录 <code>mkdir $GOPATH/src/github.com/derekparker &amp;&amp; cd $GOPATH/src/github.com/derekparker</code></li>
<li>克隆项目并且打开 <code>git clone https://github.com/derekparker/delve.git &amp;&amp; cd delve</code></li>
<li>Go 1.5 需要执行的命令。 <code>export GO15VENDOREXPERIMENT=1</code></li>
<li>开始安装 <code>CERT=dlv-cert make install</code></li>
</ul>
<h1 id="如何断点调试"><a href="#如何断点调试" class="headerlink" title="如何断点调试"></a>如何断点调试</h1><p>调试模式 <img src="https://camo.githubusercontent.com/68208a6fb64ec6fd62130fdc9d1846ce2ee32528/687474703a2f2f692e67697068792e636f6d2f336f4564754f3952783661776b64733465732e676966" alt="调试模式"></p>
<p>第一次进入断点调试的时候，需要配置一些调试信息，步骤如下：</p>
<ol>
<li>在 VS Code 中，切换到debug面板，快捷键是 <code>⌘+⇧+D</code>。</li>
<li>点击左上角的齿轮图标（Open launch.json）。</li>
<li>选择 Go 环境。</li>
</ol>
<p><img src="http://ww4.sinaimg.cn/large/4da583a7jw1f4jj3eq25gj20zi08jjrx.jpg" alt="如何配置调试信息"></p>
<p><code>launch.json</code> 配置信息如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"version"</span>: <span class="string">"0.2.0"</span>,</div><div class="line">    <span class="attr">"configurations"</span>: [</div><div class="line">        &#123;</div><div class="line">            <span class="attr">"name"</span>: <span class="string">"Phantom"</span>,</div><div class="line">            <span class="attr">"type"</span>: <span class="string">"go"</span>,</div><div class="line">            <span class="attr">"request"</span>: <span class="string">"launch"</span>,</div><div class="line">            <span class="attr">"mode"</span>: <span class="string">"debug"</span>,</div><div class="line">            <span class="attr">"remotePath"</span>: <span class="string">""</span>,</div><div class="line">            <span class="attr">"port"</span>: <span class="number">1234</span>,</div><div class="line">            <span class="attr">"host"</span>: <span class="string">"127.0.0.1"</span>,</div><div class="line">            <span class="attr">"program"</span>: <span class="string">"$&#123;workspaceRoot&#125;"</span>,</div><div class="line">            <span class="attr">"env"</span>: &#123;</div><div class="line">                <span class="attr">"QUICKPAY_ENV"</span>: <span class="string">"testing"</span></div><div class="line">            &#125;,</div><div class="line">            <span class="attr">"args"</span>: []</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在需要调试的代码附近打个断点后，按 <code>F5</code> 即可开始断点调试了。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://www.cnblogs.com/zsy/p/5224524.html" target="_blank" rel="external">http://www.cnblogs.com/zsy/p/5224524.html</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=lukehoban.Go" target="_blank" rel="external">https://marketplace.visualstudio.com/items?itemName=lukehoban.Go</a></li>
<li><a href="https://github.com/derekparker/delve/blob/master/Documentation/installation/osx/install.md" target="_blank" rel="external">https://github.com/derekparker/delve/blob/master/Documentation/installation/osx/install.md</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍的是如何使用VS Code 搭建一个进行Go开发的IDE。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Note&lt;/code&gt;: 本文的所有操作都是在 OS X系统上进行的。&lt;/p&gt;
&lt;h1 id=&quot;VS-Code-介绍&quot;&gt;&lt;a href=&quot;#VS-Code-介绍&quot; class=&quot;headerlink&quot; title=&quot;VS Code 介绍&quot;&gt;&lt;/a&gt;VS Code 介绍&lt;/h1&gt;&lt;p&gt;VS Code 是微软开源的一个编辑器软件。刚面世的时候侧重于 C# 和前端开发，随着版本迭代和新功能出现，特别是支持安装第三方插件，VS Code 也支持其它语言的开发。&lt;/p&gt;
&lt;p&gt;​VS Code 原生支持智能提示、方法补全的语言有：JavaScript, JSON, HTML, CSS, LESS, SASS。如果装上下文提到的 Go 插件，也是能够支持 Go 语言的智能提示和方法补全。&lt;/p&gt;
&lt;p&gt;VS Code 最牛逼的地方是 它和 Atom 都是基于 Electron 构建的应用，但是相比于 Atom 常被诟病的卡卡卡，VS Code 打开超大文件几乎秒开。&lt;/p&gt;
&lt;p&gt;不足的地方是 VS Code 的第三方插件的丰富度不及 Atom，但是假以时日，随着更多人关注它，VS Code 的第三方插件肯定会越来越丰富。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Go" scheme="http://yoursite.com/tags/Go/"/>
    
      <category term="VS Code" scheme="http://yoursite.com/tags/VS-Code/"/>
    
      <category term="Go Debug" scheme="http://yoursite.com/tags/Go-Debug/"/>
    
      <category term="IDE" scheme="http://yoursite.com/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】On the ES6 module syntax</title>
    <link href="http://yoursite.com/2016/03/28/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91On%20the%20ES6%20module%20syntax/"/>
    <id>http://yoursite.com/2016/03/28/【翻译】On the ES6 module syntax/</id>
    <published>2016-03-28T13:29:09.000Z</published>
    <updated>2016-03-28T13:30:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章将会探索ES6的模块以及它与Node的模块（commonJS）的不同。模块系统本质上就是一种从一个文件中引用另一个文件的方法。基本上任何东西都可以被赋值给一个变量。模块系统选择一系列标准的愈发来使得它更容易书写。</p>
<a id="more"></a>
<p>先前，我只使用过Node的模块系统。随着我最近探索ES6，我发现Node和ES6的模块系统之间有一些不一样的。本质上，它们做的是同样的事，但是它们的语法有些轻微的不同。</p>
<p>让我们以一个可以给你推荐一杯鸡尾酒的函数作为例子。为了保持简单，这个函数总是会给你推荐一杯“Sazerac”鸡尾酒（这不是一个坏事情）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCocktail</span>(<span class="params"></span>) </span>&#123;    </div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="string">"Sazerac"</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在Node中，如果你想在一个文件中定义这个函数，然后在另一个文件中使用它，你将会使用<code>module.exports</code>。</p>
<p><code>cocktail.js</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCocktail</span>(<span class="params"></span>) </span>&#123;    </div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="string">"Sazerac"</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = getCocktail;</div></pre></td></tr></table></figure>
<p>要想在另一个文件中使用它，你必须使用<code>require</code>。</p>
<p><code>app.js</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> getCocktail = <span class="built_in">require</span>(<span class="string">'./cocktail'</span>);   </div><div class="line"></div><div class="line"><span class="comment">// you don't need the file extension here</span></div><div class="line"></div><div class="line"><span class="comment">// ./ means that you are including a file from the same directory</span></div><div class="line"></div><div class="line"><span class="comment">// the variable getCocktail is now set to the function getCocktail() from cocktail.js</span></div><div class="line"></div><div class="line"><span class="comment">// this means we can call it:</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(getCocktail()) <span class="comment">// logs "Sazerac";</span></div></pre></td></tr></table></figure>
<p>这就是Node处理模块系统的方法，ES6的模块方法则有些不一样。</p>
<p><code>cocktail.js</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCocktail</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    retrun <span class="string">"Sazerac"</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> getCocktail;</div></pre></td></tr></table></figure>
<p><code>app.js</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">'getCocktail'</span> <span class="keyword">from</span> <span class="string">'./cocktail'</span> <span class="comment">// you don't net the file extension here either;</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(getCocktail()); <span class="comment">// "Sazerac";</span></div></pre></td></tr></table></figure>
<p>让我们来总结下Node和ES6的不同， 如何引入：</p>
<ul>
<li><p><code>require(&#39;module&#39;)</code> // Node</p>
</li>
<li><p><code>import thing from &#39;module&#39;</code> // ES6</p>
</li>
</ul>
<p>以及如何导出：</p>
<ul>
<li><p><code>module.exports = thing // Node</code></p>
</li>
<li><p><code>export default thing</code> // ES6</p>
</li>
</ul>
<h3 id="导出多种东西"><a href="#导出多种东西" class="headerlink" title="导出多种东西"></a>导出多种东西</h3><p>模块系统的一个共同用例是一个模块可以导出好几个关联的东西。我们来扩展鸡尾酒例子，让它能够给你推荐威士忌、杜松子酒和处女鸡尾酒。</p>
<p>在Node中，你可以导出一个包含多样东西的对象：</p>
<p><code>cocktail.js</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getWhiskyCocktail</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="string">"Sazerac"</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGinCocktail</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="string">"Martini"</span>; <span class="comment">// stirred, obviously</span></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getVirginCocktail</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="string">"Virgin Mary"</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;getGinCocktail, getVirginCocktail, getWhiskyCocktail&#125;;</div></pre></td></tr></table></figure>
<p>为了调用它，你得通过一个对象才能做到：</p>
<p><code>app.js</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> cockttails = <span class="built_in">require</span>(<span class="string">'./cocktail'</span>);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(cocktails.getGinCocktail()); <span class="comment">// Martini</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(cocktails.getVirginCocktail()); <span class="comment">// Virgin Mary</span></div></pre></td></tr></table></figure>
<p>我个人认为， ES6在这方面做个稍微好点。</p>
<p><code>cocktail.js</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getWhiskyCocktail</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="string">"Sazerac"</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGinCocktail</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="string">"Martini"</span>; <span class="comment">// stirred, obviously</span></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getVirginCocktail</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="string">"Virgin Mary"</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">export</span> &#123;getGinCocktail, getVirginCocktail, getWhiskyCocktail&#125;;</div></pre></td></tr></table></figure>
<p><code>app.js</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> &#123;getGinCocktail, getVirginCocktail&#125; <span class="keyword">from</span> <span class="string">'./cocktail'</span>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(cocktails.getGinCocktail()); <span class="comment">// Martini</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(cocktails.getVirginCocktail()); <span class="comment">// Virgin Mary</span></div></pre></td></tr></table></figure>
<p>正如你所见，首先，你可以直接调用函数而不必通过一个对象。另外，ES6模块系统能够让你只引入你需要的函数（所以如果你不是一个威士忌粉丝， 这将非常适合你）。如果你正在性能优化，这也许会节约一些内存使用，但是我不确定。（谁能够证实或否定它？）</p>
<p>细心的观众可能注意到第一个ES6例子使用 <code>export default thing</code>，而第二个例子使用 <code>export {thing, otherThing}</code>。如果你正在写一个模块并且你推测一个方法将会比其他方法使用得更频繁，你可以将它设置成默认。你可以同时使用默认或者非默认（命名）导出。</p>
<p><code>cocktail.js</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> getWhiskyCocktail;</div><div class="line"></div><div class="line"><span class="keyword">export</span> &#123;getGinCocktail, getVirginCocktail&#125;;</div></pre></td></tr></table></figure>
<p>所以如果你只是对默认的威士忌酒感兴趣，你可以这么写：</p>
<p><code>app.js</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> getWhiskyCocktail <span class="keyword">from</span> <span class="string">'./cocktail'</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(getWhiskyCocktail()); <span class="comment">// Sazerac</span></div></pre></td></tr></table></figure>
<p>或者你既想要默认的威士忌酒也想要处女鸡尾酒：</p>
<p><code>app.js</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> getWhiskyCocktail, &#123;getVirginCocktail&#125; <span class="keyword">from</span> <span class="string">'./cocktail'</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(getWhiskyCocktail()); <span class="comment">// Sazerac</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(getVirginCocktail()); <span class="comment">// Virgin Mary</span></div></pre></td></tr></table></figure>
<p>必需注意到ES6表示导入命名的导出方法是它被花括号包围着，即使你只是导入它们中的一个，这非常重要。如果你没有使用花括号，你将会试图是访问默认的导出方法。我一开始就在这上面踩了坑。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">export</span> &#123;getGinCocktail, getVirginCocktail, getWhiskyCocktail&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> getWhiskyCocktail <span class="keyword">from</span> <span class="string">'./cocktail'</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(getWhiskyCocktail()); <span class="comment">// error!</span></div></pre></td></tr></table></figure>
<p>如果你愿意的话，你也可以在导入方法的时候使用<code>as newName</code>来重命名它们。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> &#123;getWhiskyCocktail <span class="keyword">as</span> getCocktail&#125; <span class="keyword">from</span> <span class="string">'./cocktail'</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(getCocktail()); <span class="comment">// Sazerac</span></div></pre></td></tr></table></figure>
<p>关于ES6模块系统还有更多的东西，我今天只是覆盖了一点点。如果你想要链接更多，我给你推荐一下的资源：</p>
<ul>
<li><p><a href="https://developer.mozilla.org/en/docs/web/javascript/reference/statements/import" target="_blank" rel="external">MDN article on import</a></p>
</li>
<li><p><a href="https://developer.mozilla.org/en/docs/web/javascript/reference/statements/export" target="_blank" rel="external">MDN article on export</a></p>
</li>
<li><p><a href="http://exploringjs.com/es6/ch_modules.html#ch_modules" target="_blank" rel="external">ExploringJS article on ES6 modules</a></p>
</li>
</ul>
<p>我讲完了，非常感谢你的阅读。</p>
<p><a href="http://tiljs.jegtnes.co.uk/es6-module-syntax/" target="_blank" rel="external">原文链接</a></p>
<p>作者： Alex Jegtnes</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章将会探索ES6的模块以及它与Node的模块（commonJS）的不同。模块系统本质上就是一种从一个文件中引用另一个文件的方法。基本上任何东西都可以被赋值给一个变量。模块系统选择一系列标准的愈发来使得它更容易书写。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="module" scheme="http://yoursite.com/tags/module/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】深入理解ES6：箭头函数</title>
    <link href="http://yoursite.com/2015/06/17/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%EF%BC%9A%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2015/06/17/【翻译】深入理解ES6：箭头函数/</id>
    <published>2015-06-17T08:49:36.000Z</published>
    <updated>2016-03-28T12:58:40.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><a href="https://hacks.mozilla.org/category/es6-in-depth/" target="_blank" rel="external">深入理解ES6</a>  是介绍ECMAScript 6.0版标准（简称 ES6）中加入到JavaScript编程语言新特性的系列文章。</p>
</blockquote>
<a id="more"></a>
<p>箭头在一开始就已经成为JavaScript的一部分。在最开始的JavaScript教程就建议把行内脚本包裹在HTML注释里面。这将会阻止不支持JS的浏览器错误地将JS代码显示在文本中。你可能会这样子写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;script language=<span class="string">"javascript"</span>&gt;</div><div class="line">&lt;!--</div><div class="line">  document.bgColor = "brown";  // red</div><div class="line">// --&gt;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>旧的浏览器将会解析成两个不支持的标签和一段注释；而新的浏览器将会解析成JS代码。</p>
<p>为了支持这种古怪的技巧，浏览器中的JavaScript引擎将会把字符 &lt;!– 当作单行注释的开始。这并不是在开玩笑，而是一直以来都是JavaScript语言的一部分，直到现在，不仅仅是在行内&lt;script&gt;标签的顶部能够正常运行，而且是在JS代码的任何地方，甚至包括在Node中。</p>
<p>碰巧的是这种风格的注释第一次在ES6中被标准化。不过这不是我们在这里谈论的箭头。</p>
<p>箭头序列 –&gt; 也表示一个单行注释。奇怪的是，在HTML中，–&gt;之前的字符表示注释的一部分，而在JS中，–&gt; 所在行后面剩下的部分表示注释。</p>
<p>这变得更奇怪了。只有当 –&gt; 箭头出现在一行的开始部分，它才表示一个注释。这是因为在别的JS上下文中，–&gt; 是一个操作符，表示“goes to”。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">countdown</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">while</span> (n --&gt; <span class="number">0</span>)  <span class="comment">// "n goes to zero"</span></div><div class="line">    alert(n);</div><div class="line">  blastoff();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="http://codepen.io/anon/pen/oXZaBY?editors=001" target="_blank" rel="external">上面的代码是真的能够运行的。</a>当n变成0的时候，循环才会停止。这不是ES6的新特性，而是已有特性的组合，所以会带来一点误导。你能弄清楚这是怎么回事吗？照例你可以在<a href="http://stackoverflow.com/questions/1642028/what-is-the-name-of-the-operator" target="_blank" rel="external">Stack Overflow</a>上找到问题的答案。</p>
<p>当然还有一个小于或等于的操作符，&lt;=。也许你能够在你的JS代码中找出更多的箭头，但是我们就此打住，你应该注意到我们遗落了一个箭头符号。</p>
<table style="width: 250px;margin: 0 auto;"><br>    <tr style="border:1px solid #ddd;"><td>&lt;!–    single-line comment</td></tr><br>    <tr style="border:1px solid #ddd;"><td>–&gt;    “goes to” operator</td></tr><br>    <tr style="border:1px solid #ddd;"><td>&lt;=    less than or equal to</td></tr><br>    <tr style="border:1px solid #ddd;"><td>=&gt;    ???</td></tr><br></table>

<p>=&gt; 操作符到底发生了什么？今天我们就要探究这个问题。</p>
<p>首先我们先谈论下函数。</p>
<p>###无处不在的函数表达式</p>
<p>JavaScript中一个有趣的特性是，任何时候，当你需要一个函数，你只需在运行的代码的右侧输入函数就可以。</p>
<p>举个例子，假设你正打算让用户点击了浏览器上特定按钮的时候，浏览器做点什么，于是你敲了下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">"#confetti-btn"</span>).click(</div></pre></td></tr></table></figure>
<p>jQuery的 .click() 方法需要一个参数：一个函数。没问题，你正好在右侧输入一个函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">"#confetti-btn"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">  playTrumpet();</div><div class="line">  fireConfettiCannon();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这样子写代码对我们现在来说是相当自然而然的。在JavaScript推广这种编程方式之前，很多语言都没有这种特征，所以我们会觉得很奇怪。当然Lisp早在1958年就有函数表达式，也称作lambda函数。但是像 C++、Python、C#以及Java在很长的时间里是没有函数表达式。</p>
<p>现在，上面的四种语言不再没有lambda函数了。新出现的编程语言无一例外地拥有内建的lambda函数。我们得感谢JavaScript和早期的JavaScript程序员，因为他们无畏地建立了许多严重依赖lambda的函数库，并且使得这种特征被广泛地采纳。</p>
<p>然而略带忧伤的是，上面我所提到的编程语言中，JavaScript的lambda函数语法被证明是最啰嗦的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// A very simple function in six languages.</div><div class="line">function (a) &#123; return a &gt; 0; &#125; // JS</div><div class="line">[](int a) &#123; return a &gt; 0; &#125;  // C++</div><div class="line">(lambda (a) (&gt; a 0))  ;; Lisp</div><div class="line">lambda a: a &gt; 0  # Python</div><div class="line">a =&gt; a &gt; 0  // C#</div><div class="line">a -&gt; a &gt; 0  // Java</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://hacks.mozilla.org/category/es6-in-depth/&quot;&gt;深入理解ES6&lt;/a&gt;  是介绍ECMAScript 6.0版标准（简称 ES6）中加入到JavaScript编程语言新特性的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="lambda" scheme="http://yoursite.com/tags/lambda/"/>
    
  </entry>
  
  <entry>
    <title>弹幕、抽奖及投票</title>
    <link href="http://yoursite.com/2015/05/05/%E5%BC%B9%E5%B9%95%E3%80%81%E6%8A%BD%E5%A5%96%E5%8F%8A%E6%8A%95%E7%A5%A8/"/>
    <id>http://yoursite.com/2015/05/05/弹幕、抽奖及投票/</id>
    <published>2015-05-05T15:10:19.000Z</published>
    <updated>2016-03-28T12:58:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>#前言<a href="#introduction"></a>#</p>
<p>距离年会还有一两个月…</p>
<p>赵总: 我们今年的年会要搞得有点创意。</p>
<p>众程序猿: 什么是有点创意？</p>
<p>赵总: 至少那个奖项投票结果要像星光大道那样，有动画!</p>
<p>众程序猿: 哦…</p>
<a id="more"></a>
<p>#抽奖(老虎机)#<br><img src="http://ww4.sinaimg.cn/mw1024/4da583a7gw1ervpx5zqtej21hc0u0dz1.jpg" alt=""></p>
<p>###requestAnimationFrame###</p>
<p>######requestAnimationFrame是什么？######</p>
<p>在浏览器动画程序中，我们通常使用一个定时器来循环每隔几毫秒移动目标物体一次，来让它动起来。这个requestAnimationFrame()函数就是针对动画效果的API，你可以把它用在DOM上的风格变化或画布动画或WebGL中。</p>
<p>######使用requestAnimationFrame有什么好处？######</p>
<p>浏览器可以优化并行的动画动作，更合理的重新排列动作序列，并把能够合并的动作放在一个渲染周期内完成，从而呈现出更流畅的动画效果。</p>
<p>参考： <a href="http://www.webhek.com/requestanimationframe" target="_blank" rel="external">HTML5探秘：用requestAnimationFrame优化Web动画</a></p>
<p>###js对象封装###</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义</span></div><div class="line"><span class="keyword">var</span> name = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> variate1, variate2, variate3....;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> method1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//do something</span></div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">var</span> method2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//do something</span></div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">var</span> method3 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//do something</span></div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">return</span>&#123;</div><div class="line">    <span class="attr">publicMethod</span>: method1,</div><div class="line">    <span class="attr">method2</span>: method2</div><div class="line">  &#125;</div><div class="line">&#125;();</div><div class="line"></div><div class="line"><span class="comment">//使用</span></div><div class="line">name.publicMethod();</div><div class="line">name.method2();</div></pre></td></tr></table></figure>
<p>######好处######</p>
<ol>
<li>代码结构清晰</li>
<li>防止方法名被覆盖</li>
</ol>
<p>###提高js运行的小经验###</p>
<ol>
<li>使用for()循环替代for…in循 环。因为for…in循环在开始循环之前需要Script引擎创建一个含有所有可循环属性的 List，需要多检查一次;</li>
<li>fullName += ‘John’; fullName += ‘Holdings’;执行速度快于fullName += ‘John’ + ‘Holdings’;</li>
<li>如果你需要把多个字符串连接起来，最好是把他们做成一个数组，然后调用join()方法实现这个操作。这种方式在生成HTML片段时尤其 有效。</li>
<li>对于简单的任务，最好使用基本操作方式来实现，而不是使用函数调用实现。例如val1 &lt; val2 ? val1 : val2;执行速度快于Math.min(val1, val2);，类似的，myArr.push(newEle);慢于myArr[myArr.length] = newEle;</li>
<li>当你对对象的成员（属性或方法）进行反复操作时，先存储对它们的引用。例如var getTags = document.getElementsByTagName; getTags(‘div’);</li>
<li>for(var i=0; i &lt; someArray.length; i++) {…}的执行效率慢于for (var i=0, loopLen=someArray.length; i&lt;loopLen; i++) {…}。</li>
<li>尽可能的使用原始JavaScript。限制JavaScript框架的使用。</li>
<li>…</li>
</ol>
<p>参考： <a href="http://www.vaikan.com/30-best-practices-to-boost-your-web-application-performance/" target="_blank" rel="external">30个提高Web程序执行效率的好经验</a></p>
<p>###动画核心(scrollTop属性)###</p>
<p><code>scrollTop</code>属性设置或者返回一个元素在垂直方向上的滚动像素值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> animate = <span class="function"><span class="keyword">function</span>(<span class="params">now</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!start) start = now;</div><div class="line">    <span class="keyword">var</span> t = now - start || <span class="number">0</span>;</div><div class="line">    <span class="comment">//定义滚动动画，从第stepFlag开始到结束，头一个慢慢减速停止，剩下的无序滚动</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = stepFlag; i &lt; layout; ++i) &#123;</div><div class="line">        <span class="keyword">if</span> (i &lt;= stepFlag) &#123;</div><div class="line">            $reels[i].scrollTop = (speeds[i] / tMax / <span class="number">2</span> * (tMax - t) * (tMax - t)) % (employees.length * imgHeight) + r[i] * imgHeight | <span class="number">0</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            $reels[i].scrollTop += (<span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span> ? <span class="number">-1</span> : <span class="number">1</span>) * imgHeight * <span class="built_in">Math</span>.random() * <span class="number">5</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>参考：<a href="http://www.w3schools.com/jsref/prop_element_scrolltop.asp" target="_blank" rel="external">HTML DOM scrollTop Property</a></p>
<p>###背景音乐(HTML5 audio)###</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//播放背景音乐</span></div><div class="line"><span class="keyword">var</span> playSong = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> song = <span class="built_in">document</span>.getElementById(<span class="string">'song'</span>);</div><div class="line">    song.volume = <span class="number">1</span>;</div><div class="line">    song.play();</div><div class="line">&#125;;</div><div class="line"><span class="comment">//暂停背景音乐</span></div><div class="line"><span class="keyword">var</span> stopSong = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//渐渐关小音量</span></div><div class="line">    <span class="keyword">var</span> song = <span class="built_in">document</span>.getElementById(<span class="string">'song'</span>);</div><div class="line">    <span class="keyword">var</span> fadeOut = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (song.volume &gt; <span class="number">0</span>) &#123;</div><div class="line">            song.volume -= <span class="number">0.1</span>;</div><div class="line">            song.volume = <span class="built_in">parseFloat</span>(song.volume.toFixed(<span class="number">1</span>));</div><div class="line">            <span class="built_in">console</span>.log(song.volume);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            song.pause();</div><div class="line">            clearInterval(fadeOut);</div><div class="line">        &#125;</div><div class="line">    &#125;, <span class="number">300</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>参考：<a href="http://www.w3schools.com/tags/tag_audio.asp" target="_blank" rel="external">HTML audio Tag</a></p>
<p>#投票结果展示#<br><img src="http://ww4.sinaimg.cn/mw1024/4da583a7gw1ervpx871byj21hc0u07ft.jpg" alt=""></p>
<p>###D3.js###<br>d3.js是一个优秀的数据可视化库，可以让我们方便快捷地实现数据到图形的变换。但是：</p>
<ol>
<li>d3.js不是一个图形绘制库，不像<a href="http://echarts.baidu.com" target="_blank" rel="external">echarts</a>、<a href="http://www.hcharts.cn/" target="_blank" rel="external">highcharts</a>等图形库，提供了各种图形的接口供用户使用。</li>
<li>d3.js是一个基于集合概念的 DOM操作库。类似jQuery，依赖于选择符选中一组元素，建立一个集合，然后使用集合对象的方法操作DOM。</li>
<li>d3.js的大量功能集中在<code>数据处理</code>方面。将数据映射到图形，做诸如数据范围的变换、插值的计算、布局的计算等等。</li>
<li>d3.js的核心是对<code>数据</code>和<code>可视化元素</code>的匹配。d3将数据可视化抽象为数据与可视化元素的匹配，一个<code>数据</code>对应一个<code>可视化元素</code>，一个<code>数值</code>对应一个可视化元素的<code>属性</code>。</li>
</ol>
<p><img src="http://ww3.sinaimg.cn/mw1024/4da583a7jw1erts091r3xj20l00kuwjj.jpg" alt=""></p>
<p>###SVG和Html5 Canvas###</p>
<p>#####Canvas</p>
<ul>
<li>基于像素（canvas 实质上是一种带有绘图 API 的图像元素）</li>
<li>单个 HTML 元素，其行为类似于 <code>&lt;img&gt;</code></li>
<li>通过脚本以编程方式创建和修改视觉呈现</li>
<li>事件模型/用户交互是粗粒度的—仅在 canvas 元素级别；必须通过鼠标坐标对交互进行手动编程设置</li>
<li>API 不支持可访问性；除了 canvas，还必须使用基于标记的技术</li>
</ul>
<p>#####SVG</p>
<ul>
<li>基于对象模型（SVG 元素类似于 HTML 元素）</li>
<li>多个图形元素，是文档对象模型 (DOM) 的一部分</li>
<li>使用标记创建视觉呈现，并通过 CSS 或通过脚本以编程方式修改视觉呈现</li>
<li>事件模型/用户交互是基于对象的，在最基本的图像元素级别进行——线条、矩形、路径</li>
<li>SVG 标记和对象模型直接支持可访问性</li>
</ul>
<p>Canvas 是一种位图，采用直接模式 (immediate mode)的图形应用程序编程接口 (API) 在其上进行绘图。 Canvas 是一种“发后不理”(Fire and Forget) 模型，在这种模式下，将直接向位图呈现其图形，之后对绘制的形状并不知晓；最后只呈现生成的位图。</p>
<p>SVG 是一种保留模式 (retained mode)的图形模型，是一种在内存中进行持久处理的模型。类似于 HTML，SVG 构建了包含图元、属性和样式的对象模型。<br>在 HTML5 文档中出现 <code>&lt;svg&gt;</code> 元素时，它的作用类似于一个内联块，并且是 HTML 文档树的一部分。</p>
<p>可以认为 Canvas 类似于 Windows GDI API，您通过编程方式向窗口中绘制图形；而 SVG 类似于 HTML 标记，具有元素、样式、事件和基于 DOM 的编程能力。Canvas 是过程性的，而 SVG 是声明性的。</p>
<p>#####结论</p>
<p><img src="https://i-msdn.sec.s-msft.com/hh377884.15(zh-cn,MSDN.10).jpg" alt="111"></p>
<p>#弹幕#</p>
<p>###功能介绍</p>
<ul>
<li>弹幕——连接手机和大屏幕，在屏幕上更大胆的表达和吐槽。<br><img src="http://ww1.sinaimg.cn/mw1024/4da583a7jw1erts9eyvjuj21he0kgwjq.jpg" alt=""></li>
</ul>
<p>###技术实现<br><img src="http://ww4.sinaimg.cn/mw1024/4da583a7jw1erts9hdeoyj21ck0pwwia.jpg" alt=""></p>
<p>###局限性和想象</p>
<ul>
<li>表现方式较单一<ul>
<li>声音</li>
<li>动画</li>
</ul>
</li>
<li>可以尝试加入@功能</li>
<li>Source Code<br><a href="https://github.com/CardInfoLink/danmu/tree/develop/windows" target="_blank" rel="external">https://github.com/CardInfoLink/danmu/tree/develop/windows
</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#前言&lt;a href=&quot;#introduction&quot;&gt;&lt;/a&gt;#&lt;/p&gt;
&lt;p&gt;距离年会还有一两个月…&lt;/p&gt;
&lt;p&gt;赵总: 我们今年的年会要搞得有点创意。&lt;/p&gt;
&lt;p&gt;众程序猿: 什么是有点创意？&lt;/p&gt;
&lt;p&gt;赵总: 至少那个奖项投票结果要像星光大道那样，有动画!&lt;/p&gt;
&lt;p&gt;众程序猿: 哦…&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="svg" scheme="http://yoursite.com/tags/svg/"/>
    
      <category term="canvas" scheme="http://yoursite.com/tags/canvas/"/>
    
      <category term="d3.js" scheme="http://yoursite.com/tags/d3-js/"/>
    
      <category term="html5" scheme="http://yoursite.com/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】jQuery和React.js的思考</title>
    <link href="http://yoursite.com/2015/04/01/jQuery%E5%92%8CReactjs%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://yoursite.com/2015/04/01/jQuery和Reactjs的思考/</id>
    <published>2015-04-01T03:27:05.000Z</published>
    <updated>2016-03-28T12:58:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接: <a href="http://blog.zigomir.com/react.js/jquery/2015/01/11/jquery-versus-react-thinking.html" target="_blank" rel="external">jQuery versus React.js thinking</a></p>
<p>本质上，我不喜欢辩论技术之间的好坏。我认为每一个相当成功的库或者框架在它刚开始推出来到成功都是有很好的理由的。我将会从概念上来比较jQuery和React的不同。</p>
<a id="more"></a>
<p>##问题<br>一组列表。每一项都有一个默认隐藏的详细信息。任何时候，用户点击列表中的一项，那一项都会展开并且展示它的详细信息，其它项将会变成灰色。如果我们再次点击同一项，它将会收缩并且所有项都会变成它们的初始状态，折叠的并且字体变成黑色的。我们也可以从一个展开的项转移到另一项，折叠前一项，展开新的那项。</p>
<p>##两种解决方法</p>
<p>###jQuery(<a href="http://jsbin.com/zunev/3/edit" target="_blank" rel="external">JSBin</a>)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  $(<span class="string">'li'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> $clickedItemDetails = $(e.currentTarget).find(<span class="string">'.details'</span>);</div><div class="line">    <span class="keyword">var</span> $allDetails = $(<span class="string">'li .details'</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ($clickedItemDetails.is(<span class="string">':hidden'</span>)) &#123;</div><div class="line">      $allDetails.hide().parent().removeClass(<span class="string">'collapsed'</span>);</div><div class="line">      $clickedItemDetails.show();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      $clickedItemDetails.hide();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    $allDetails.each(<span class="function"><span class="keyword">function</span>(<span class="params">index, el</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> ($(el).is(<span class="string">':hidden'</span>)) &#123;</div><div class="line">        $(el).parent().addClass(<span class="string">'collapsed'</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ($(<span class="string">'li.collapsed'</span>).length === $(<span class="string">'li'</span>).length) &#123;</div><div class="line">      $(<span class="string">'li'</span>).removeClass(<span class="string">'collapsed'</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>我们的数据和它的状态不是有组织化的，并且分布在DOM中。数据、状态和展示的分隔是模糊的。</p>
<p>我们用jQuery的选择器（类似：<code>is(&#39;:hidden&#39;)</code>和<code>.find(&#39;.details&#39;)</code>）从DOM中查找数据。然后我们用<code>hide()</code>,<code>show()</code>,<code>addClass()</code>和<code>removeClass()</code>函数直接在DOM上修改状态。</p>
<p>在最开始的时候，我这样子写过一些代码，现在回过来想读它的时候，我需要整理下思绪来重新读懂它。因为功能是如此的有限所以我可以不用破坏它的代码就能重构，但是当我想给它添加更复杂的功能的话将不会是件容易的事。</p>
<p>###React(<a href="http://jsbin.com/hotod/12/edit" target="_blank" rel="external">JSBin</a>)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** @jsx React.DOM */</span></div><div class="line"><span class="keyword">var</span> PRODUCTS = [</div><div class="line">  &#123;</div><div class="line">    <span class="string">"id"</span>: <span class="number">1</span>, <span class="string">"name"</span>: <span class="string">"Bag of suck"</span>, <span class="string">"price"</span>: <span class="number">100</span>,</div><div class="line">    <span class="string">"details"</span>: <span class="string">"You don't want to own this!"</span></div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    <span class="string">"id"</span>: <span class="number">2</span>, <span class="string">"name"</span>: <span class="string">"Bag of luck"</span>, <span class="string">"price"</span>: <span class="number">200</span>,</div><div class="line">    <span class="string">"details"</span>: <span class="string">"You might want to own this!"</span></div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    <span class="string">"id"</span>: <span class="number">3</span>, <span class="string">"name"</span>: <span class="string">"Bag of fuck"</span>, <span class="string">"price"</span>: <span class="number">300</span>,</div><div class="line">    <span class="string">"details"</span>: <span class="string">"You really want to own this!"</span></div><div class="line">  &#125;</div><div class="line">];</div><div class="line"></div><div class="line"><span class="keyword">var</span> ItemsList = React.createClass(&#123;</div><div class="line">  <span class="attr">getInitialState</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">expandedProductId</span>: <span class="literal">null</span></div><div class="line">    &#125;;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="attr">handleProductClick</span>: <span class="function"><span class="keyword">function</span>(<span class="params">product</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> newSelectedProductId = product.id;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.expandedProductId === product.id) &#123;</div><div class="line">      newSelectedProductId = <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">expandedProductId</span>: newSelectedProductId&#125;);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>, noneSelected = <span class="keyword">this</span>.state.expandedProductId === <span class="literal">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> products = PRODUCTS.map(<span class="function"><span class="keyword">function</span>(<span class="params">product</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> details, isExpanded = self.state.expandedProductId === product.id;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (isExpanded) &#123;</div><div class="line">        details = &lt;div&gt;&#123;product.details&#125;&lt;/div&gt;;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">return</span> (</div><div class="line">        &lt;li key=&#123;product.id&#125;</div><div class="line">            onClick=&#123;self.handleProductClick.bind(self, product)&#125;</div><div class="line">            className=&#123;isExpanded || noneSelected ? '' : 'collapsed'&#125;&gt;</div><div class="line">          &#123;product.name&#125; (&#123;product.price&#125;)</div><div class="line">          &#123;details&#125;</div><div class="line">        &lt;/li&gt;</div><div class="line">      );</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;ul&gt;</div><div class="line">        &#123;products&#125;</div><div class="line">      &lt;/ul&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">React.render(&lt;ItemsList /&gt;, document.body);</div></pre></td></tr></table></figure></p>
<p>我最开始反应“哇，更多的代码，感觉更糟了”，但是没有，为什么呢？</p>
<ul>
<li>数据非常好地在<code>PRODUCTS</code>数组中隔离开。</li>
<li>所有的状态我们都存储在<code>expandedProductId</code>。</li>
<li>所有的表现逻辑都写在<code>render</code>方法中。</li>
<li>我们可以从上到下读取代码。</li>
<li>快速地浏览后，我可以轻易的理解它做的所有事（你也许还不知道React，但是它非常容易学习）。</li>
</ul>
<p>##结论<br>我知道这是个相当微不足道的例子。但是它确实显示了不同库（框架）之间根本上的不同，并且它们是怎样帮助你隔离关注点。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文链接: &lt;a href=&quot;http://blog.zigomir.com/react.js/jquery/2015/01/11/jquery-versus-react-thinking.html&quot;&gt;jQuery versus React.js thinking&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本质上，我不喜欢辩论技术之间的好坏。我认为每一个相当成功的库或者框架在它刚开始推出来到成功都是有很好的理由的。我将会从概念上来比较jQuery和React的不同。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="jQuery" scheme="http://yoursite.com/tags/jQuery/"/>
    
      <category term="React.js" scheme="http://yoursite.com/tags/React-js/"/>
    
      <category term="Front end" scheme="http://yoursite.com/tags/Front-end/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统Go开发环境搭建</title>
    <link href="http://yoursite.com/2015/03/28/Go%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2015/03/28/Go开发环境搭建/</id>
    <published>2015-03-28T08:34:46.000Z</published>
    <updated>2016-03-28T12:58:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>Go 语言是由谷歌的科学家开发的，并开源的新语言，被誉为“21世纪的C语言”，它的主要目标是将静态语言的安全性和高效性与动态语言的易开发性进行有机结合，达到完美平衡，从而使编程变得更加有乐趣，而不是在艰难抉择中痛苦前行。<br><a id="more"></a></p>
<p>最近有一个项目是处理瞬间高并发的请求，考虑到Go语言的原生支持并发的特性，以及新年之后多个项目用Go语言开发，项目组决定用Go语言开发前端抗洪服务器。工欲善其事，必先利其器，下面贴出Linux系统下Go开发环境的搭建。</p>
<p>网上有很多关于Go环境搭建的资料，都是先从安装<code>mercurial</code>开始，然后下载Go语言源码安装的。但是因为众所周知的原因，在中国大陆无法稳定地访问谷歌的服务器，所以上面那个方法很多情况下是不可行的，除非使用了代理。以下介绍一个非常简单而且非常有效的方法来搭建Go开发环境。</p>
<p><code>注意</code>:在Linux下安装Go开发环境请使用root用户。</p>
<p>####下载Go文件压缩包<br>到<a href="http://www.golangtc.com/download" target="_blank" rel="external">Golang中国社区</a>下载Go语言的源码，Linux命令行下可以执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget http://www.golangtc.com/static/go/go1.4.2.linux-amd64.tar.gz</div></pre></td></tr></table></figure></p>
<p>下载完后解压文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -zxvf go1.4.2.linux-amd64.tar.gz</div></pre></td></tr></table></figure></p>
<p>得到一个<code>go</code>目录，执行以下命令，移动到<code>/usr/local/</code>目录下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mv go/ /usr/local/</div></pre></td></tr></table></figure></p>
<p>####Go配置环境变量<br>使用vim编辑器打开<code>/etc/profile</code>文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/profile</div></pre></td></tr></table></figure></p>
<p>在最底部加入如下内容，配置Go语言环境变量：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#set <span class="keyword">go</span> environment</div><div class="line">GOROOT=/usr/local/<span class="keyword">go</span></div><div class="line">GOBIN=$GOROOT/bin</div><div class="line">PATH=$PATH:$GOBIN</div><div class="line">export GOROOT GOBIN PATH</div></pre></td></tr></table></figure></p>
<p>环境变量配置在code&gt;/etc/profile文件里能保证该机器上每个用户都能使用这个环境变量。执行如下命令使环境变量生效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source /etc/profile</div></pre></td></tr></table></figure></p>
<p>验证环境变量是否生效,如果控制台输出上面配置的路径，则说明配置成功：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo $GOROOT</div></pre></td></tr></table></figure></p>
<p>切换到部署Go服务的用户下，当然可以继续是root用户下，配置<code>GOPATH</code>环境变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim ~/.profile</div></pre></td></tr></table></figure></p>
<p>在最下面编辑如下内容：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export GOPATH=~/gowork</div></pre></td></tr></table></figure></p>
<p>然后在运行如下命令使环境变量生效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source ~/.profile</div></pre></td></tr></table></figure></p>
<p>在<code>~/gowork</code>目录下创建一个<code>main.go</code>文件，写入以下内容：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    fmt.Println(<span class="string">"Hello, 世界！"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>保存后运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">go run ~/gowork/main.go</div><div class="line">Hello, 世界！</div></pre></td></tr></table></figure></p>
<p>成功打印出信息就表示安装成功了！！</p>
<p>Go相关资料:</p>
<ol>
<li><a href="http://www.golangtc.com" target="_blank" rel="external">Golang中国社区</a></li>
<li><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN" target="_blank" rel="external">《Go入门指南》无闻翻译</a></li>
<li><a href="https://gowalker.org/" target="_blank" rel="external">Go语言项目在线文档</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Go 语言是由谷歌的科学家开发的，并开源的新语言，被誉为“21世纪的C语言”，它的主要目标是将静态语言的安全性和高效性与动态语言的易开发性进行有机结合，达到完美平衡，从而使编程变得更加有乐趣，而不是在艰难抉择中痛苦前行。&lt;br&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Go" scheme="http://yoursite.com/tags/Go/"/>
    
      <category term="Development environment" scheme="http://yoursite.com/tags/Development-environment/"/>
    
  </entry>
  
  <entry>
    <title>在OSX系统上安装MySQL</title>
    <link href="http://yoursite.com/2015/03/08/Install-MySQL-In-OSX/"/>
    <id>http://yoursite.com/2015/03/08/Install-MySQL-In-OSX/</id>
    <published>2015-03-08T08:13:25.000Z</published>
    <updated>2016-03-28T12:58:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>项目需要，得在自个儿的电脑上安装MySQL，按照网上搜索出来的结果操作时遇到了一些问题，但也最终顺利安装成功，所以就写下这篇文章，记录一下。<br><a id="more"></a></p>
<p>#安装MySQL#<br>到官网下载最新版本的MySQL，写这边文章的时候Mac最新的MySQL版本为5.6.23.</p>
<p>Mac下安装MySQL有两种方式，一种为压缩包形式 另一种为.dmg文件安装包。</p>
<p>##压缩包形式的安装方法##</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ sudo mv mysql-5.1.45-osx10.6-x86_64 /usr/local/mysql</div><div class="line">$ cd /usr/local</div><div class="line">$ sudo chown -R mysql:mysql mysql</div><div class="line">$ cd mysql</div><div class="line">$ sudo scripts/mysql_install_db --user=mysql</div><div class="line">$ sudo chown -R root .</div><div class="line">$ sudo chown -R mysql data</div></pre></td></tr></table></figure>
<p>修改密码，默认的密码为空，显然不大好<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo ./mysql_secure_installation</div></pre></td></tr></table></figure></p>
<p>启动MySQL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo ./mysqld_safe</div></pre></td></tr></table></figure></p>
<p>输入刚才设置的root密码来登录MySQL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo ./mysql -u root -p 新密码</div></pre></td></tr></table></figure></p>
<p>停止MySQL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo ./mysqld_safe stop</div></pre></td></tr></table></figure></p>
<p>##安装包文件形式的安装方法##</p>
<p>安装包文件的后缀为.dmg。双击该文件即可安装。</p>
<p>###启动MySQL服务###</p>
<ol>
<li><p>如果你已经安装了MySQLStartupItem.pkg，重新启动电脑即可。</p>
</li>
<li><p>如果你有安装MySQLStartupItem.pkg或者不想启动电脑，运行：应用程序－实用工具－终端，在终端中输入命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo /Library/StartupItems/MySQLCOM/MySQLCOM start，然后输入你的系统管理员密码即可。</div></pre></td></tr></table></figure>
</li>
<li><p>最简单的方法就是打开系统偏好设置，会看到有一项MySQL，里面有一个启动MySQL的按钮。</p>
</li>
</ol>
<p>###关闭MySQL###</p>
<ol>
<li><p>终端中输入命令,然后输入你的系统管理员密码即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo /Library/StartupItems/MySQLCOM/MySQLCOM stop</div></pre></td></tr></table></figure>
</li>
<li><p>同启动MySQL服务的第三点</p>
</li>
</ol>
<p>###更改MySQL root账户密码###<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo /usr/local/mysql/bin/mysqladmin -u root password</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目需要，得在自个儿的电脑上安装MySQL，按照网上搜索出来的结果操作时遇到了一些问题，但也最终顺利安装成功，所以就写下这篇文章，记录一下。&lt;br&gt;
    
    </summary>
    
    
      <category term="Database" scheme="http://yoursite.com/tags/Database/"/>
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="OSX" scheme="http://yoursite.com/tags/OSX/"/>
    
  </entry>
  
  <entry>
    <title>使用Karma测试AngularJS代码</title>
    <link href="http://yoursite.com/2015/02/08/%E4%BD%BF%E7%94%A8Karma%E6%B5%8B%E8%AF%95Angularjs%E4%BB%A3%E7%A0%81/"/>
    <id>http://yoursite.com/2015/02/08/使用Karma测试Angularjs代码/</id>
    <published>2015-02-08T10:03:15.000Z</published>
    <updated>2016-03-28T12:58:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>###前言<br>这是一篇难产的博文，从去年写到了今年……</p>
<p>七月底到目前，已经使用了AngularJS开发了两三个项目。与之前使用的jQuery相比，Angualr非常强大，减少了一大堆的代码，印象最深的是它的双向数据绑定，一旦建立双向绑定，用户的任何变量操作都能立马同步到它绑定的变量，页面上的效果是这个值实时更新。这就意味着，当我们想要与后台服务器交互的时候，我们节省了收集数据的步骤，只需把绑定的对象放在参数里就行。</p>
<p>然而，AngularJS的强大不止如此。<a id="more"></a>AngularJS的设计目标包括如下两点：</p>
<ul>
<li>将应用逻辑与对DOM的操作解耦。这会提高代码的可测试性。</li>
<li>将应用程序的测试看的跟应用程序的编写一样重要。代码的构成方式对测试的难度有巨大的影响。</li>
</ul>
<p>没错，AngularJS最强大的功能之一就是它的高可测试性。<br>我们在浏览AngularJS的<a href="https://docs.angularjs.org/api" target="_blank" rel="external">官方文档</a>的时候总能看到每个指令后面都会有一个测试代码片段。</p>
<p>###开始之前</p>
<p>下面我将编写一个简单的网页应用，将联系人存储到本地存储（LocalStorage）中。编写这个应用时，我将践行<a href="http://zh.wikipedia.org/wiki/%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91" target="_blank" rel="external">测试驱动开发(TDD)</a>的精神。同时，路由导航方面，我不会用angular－router，而是使用ui－router。</p>
<p>###搭建项目<br>用<code>bower</code>搭建项目框架：</p>
<pre><code>mkdir karmaDmo
bower init
bower install bootstrap --save-dev
bower install angularjs --save-dev
bower install ui-router --save-dev
bower install angular-mocks --save-dev
</code></pre><p>初始化karma配置以及karma的使用，请参考我之前的文章 <a href="http://www.wonsikin.com/2014/11/26/%E5%89%8D%E7%AB%AF%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83Karma%E7%AE%80%E4%BB%8B/" target="_blank" rel="external">前端测试环境Karma简介</a>。</p>
<p>###编写测试用例</p>
<p>Karma的测试用例语法是<a href="http://jasmine.github.io/edge/introduction.html" target="_blank" rel="external">Jasmine</a>。</p>
<pre><code>describe(&apos;app.services test&apos;, function () {
  var service;
  beforeEach(function () {
    //clear localStorage,inject the service before running test
    if(window.localStorage) {
      window.localStorage.clear();
    }
    module(&apos;app.services&apos;);

    inject(function (storageService) {
      service = storageService;
    });
  });

  it(&apos;should be a string&apos;, function () {
    expect(angular.isString(service.storageKey)).toBeTruthy();
  });

  it(&apos;should be a object&apos;, function () {
    expect(angular.isObject(service.getInstance())).toBeTruthy();
  });

  it(&apos;should be an array&apos;, function () {
    expect(angular.isArray(service.getAll())).toBeTruthy();
  });

  it(&apos;should be an empty array&apos;, function () {
    expect(service.getAll().length).toEqual(0);
  });

  it(&apos;should be one item in the array&apos;, function () {
    var item = {
      name: &apos;Arthur&apos;,
      mobile: &apos;+86-13452121990&apos;
    };
    service.save(item);
    expect(service.getAll().length).toEqual(1);
  });
});
</code></pre><p>###编写实现代码</p>
<p>启动Karma测试环境，然后编辑本app的业务逻辑：</p>
<pre><code>angular.module(&apos;app.services&apos;, [])
  .factory(&apos;storageService&apos;, function () {
    var factory = {
      storageKey: &apos;contactApp&apos;,
      getInstance: function() {
        if(window.localStorage) {
          var storage = window.localStorage.getItem(factory.storageKey) || { author: &apos;Arthur&apos;, description: &apos;save contacts to localStorage&apos;, data: []};
          return angular.fromJson(storage);
        }else{
          return;
        }
      },
      saveInstance: function(instance){
        var string = angular.toJson(instance);
        window.localStorage.setItem(factory.storageKey, string);
      },
      getAll: function(){
        var result = null,
        instance = factory.getInstance();
        if(instance) {
          result = instance.data || [];
        }else{
          result = [];
        }
        return result;
      },
      save: function(item){
        if(item.key) {
          factory.update(item);
        }else{
          factory.add(item);
        }
      },
      add: function(item){
        var instance = factory.getInstance();
        item.key = new Date().getTime();
        instance.data.push(item);
        factory.saveInstance(instance);
      },
      update: function(item){
        var instance = factory.getInstance(),
            datas = instance.data;
        for(var i in datas) {
          if(datas[i].key === item.key) {
            datas[i] = item;
            break;
          }
        };
        factory.saveInstance(instance);
      }

    };
    return factory;
  });
</code></pre><p>编写完毕后，Karma监控台的所有所有测试用例都亮绿灯的话，表明业务逻辑代码都是OK的。</p>
<p>本文章例子的源代码都发布到Github上，<a href="https://github.com/wonsikin/KarmaDemo" target="_blank" rel="external">戳此查看</a>。</p>
<p>###一些思考<br>对于测试驱动开发的优劣点讨论这里不深入，但是有一点我记得很深刻。在最近的一个项目开发过程中，出现了一个bug让我们非常诧异的，因为之前的某个版本是正常的，但是在那个时候，它出问题了。我一位同事废了好大劲才发现这个bug是因为修改旧的bug才导致出现新的bug。于是我就思考，如果当时也运行着一套类似Karma这样的测试环境，我们肯定能避免这样子的问题出现的。</p>
<p>###参考</p>
<ol>
<li><a href="http://karma-runner.github.io/0.12/index.html" target="_blank" rel="external">Karma官网</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-tdd/" target="_blank" rel="external">浅谈测试驱动开发（TDD）</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###前言&lt;br&gt;这是一篇难产的博文，从去年写到了今年……&lt;/p&gt;
&lt;p&gt;七月底到目前，已经使用了AngularJS开发了两三个项目。与之前使用的jQuery相比，Angualr非常强大，减少了一大堆的代码，印象最深的是它的双向数据绑定，一旦建立双向绑定，用户的任何变量操作都能立马同步到它绑定的变量，页面上的效果是这个值实时更新。这就意味着，当我们想要与后台服务器交互的时候，我们节省了收集数据的步骤，只需把绑定的对象放在参数里就行。&lt;/p&gt;
&lt;p&gt;然而，AngularJS的强大不止如此。
    
    </summary>
    
    
      <category term="AngularJS" scheme="http://yoursite.com/tags/AngularJS/"/>
    
      <category term="Karma" scheme="http://yoursite.com/tags/Karma/"/>
    
      <category term="Test" scheme="http://yoursite.com/tags/Test/"/>
    
  </entry>
  
  <entry>
    <title>前端测试环境Karma简介</title>
    <link href="http://yoursite.com/2014/11/26/%E5%89%8D%E7%AB%AF%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83Karma%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2014/11/26/前端测试环境Karma简介/</id>
    <published>2014-11-26T08:11:28.000Z</published>
    <updated>2016-03-28T12:58:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>在开发软件的过程中，进行单元测试是非常不错的工作，也是有必要的工作。它帮助你觉得你的代码是无懈可击的，确保产品的可靠性。作为一名追求进步的的前端码农，学习前端的测试很有必要。<br><a id="more"></a></p>
<p>###Karma简介<br>Karma是由Angular团队创造的JavaScript测试运行器，实际上，它更是一个测试环境，它让你更方便的运行测试，在不知不觉中监听着源码或者测试代码的改变，然后自动执行测试。</p>
<p>在前端测试上，传统时代的测试方法是在js脚本中写上几个<code>console</code>或者<code>alert</code>语句，然后刷新浏览器，查看打印或者弹出的信息。再后来，有了火狐的firebug和Chrome DevTools，js的测试进入了打断点的时代。然而，使用Chrome DevTools也是需要刷新浏览器，然后手动的点击跳步等操作。以上两个时代，前端的测试预期说是测试，不如说是调试，因为此时的测试是代码混着调试语句，在网页应用中（浏览器上）运行。Karma改变了前端测试的工作流程，它让开发者在开发过程中只需关注编写测试用例，编写实现方法等，而无需花费太多精力在无关代码的工作上。</p>
<p>###Karma安装<br>Karma运行在Node.js上，你可以从NPM包里面获取到。</p>
<p>假设你已经安装了Node.js，按照官方推荐的方法，你可以如下安装Karma以及相关的插件：</p>
<pre><code># Install Karma:
$ npm install karma --save-dev

# Install plugins that your project needs:
$ npm install karma-jasmine karma-chrome-launcher --save-dev
</code></pre><p>以上命令将会在你的当前目录下的<code>node_modules</code>下安装<code>karma</code>、<code>karma-jasmine</code>、<code>karma-chrome-launcher</code>。并且将开发依赖包保存进package.json,方便项目的其他开发人员只需在该目录下运行<code>npm install</code>就能够安装所有的开发依赖包。</p>
<pre><code># Run Karma:
$ ./node_modules/karma/bin/karma start
</code></pre><p>以上的命令是运行Karma，但是每次都打这么长的命令很费劲啊，所以，你可以如下安装<code>karma-cli</code>，并配置到全局中:</p>
<pre><code>$ npm install -g karma-cli
</code></pre><p>成功之后，只需运行<code>karma start</code>就能启动Karma测试了。</p>
<p>###Karma配置</p>
<p>但是启动之前有个很重要的步骤－－配置Karma的测试环境。运行<code>karma init</code>可以生成配置文件：</p>
<pre><code>$ karma init my.conf.js

Which testing framework do you want to use ?
Press tab to list possible options. Enter to move to the next question.
&gt; jasmine

Do you want to use Require.js ?
This will add Require.js plugin.
Press tab to list possible options. Enter to move to the next question.
&gt; no

Do you want to capture a browser automatically ?
Press tab to list possible options. Enter empty string to move to the next question.
&gt; Chrome
&gt; Safari
&gt;

What is the location of your source and test files ?
You can use glob patterns, eg. &quot;js/*.js&quot; or &quot;test/**/*Spec.js&quot;.
Enter empty string to move to the next question.
&gt; *.js
&gt; test/*Spec.js
&gt;

Should any of the files included by the previous patterns be excluded ?
You can use glob patterns, eg. &quot;**/*.swp&quot;.
Enter empty string to move to the next question.
&gt;

Do you want Karma to watch all the files and run the tests on change ?
Press tab to list possible options.
&gt; yes

Config file generated at &quot;/path/to/your/project/my.conf.js&quot;.
</code></pre><p>配置文件的详细语法和选项说明请参考Karma官网的<a href="http://karma-runner.github.io/0.12/config/configuration-file.html" target="_blank" rel="external">configuration file docs</a>。</p>
<p>###Karma运行</p>
<p>当启动Karma的时候，配置文件的路径会作为第一个参数传递过去。默认地，Karma会在当前目录下查找<code>karma.conf.js</code>或者<code>karma.conf.coffee</code>。但是你也可以指定配置文件启动Karma，例如，启动上一步骤生成的<code>my.conf.js</code>配置文件：</p>
<pre><code># Start Karma using your configuration:
$ karma start my.conf.js
</code></pre><p>###第一个测试<br>在当前目录下创建一个test目录，然后新建一个js文件，命名为<code>testSpec.js</code>。</p>
<pre><code>|--module
|--test
  |--testSpec.js
|--my.conf.js
</code></pre><p>在<code>testSpec.js</code>中以下内容：</p>
<pre><code>/**
* Created by ArthurWANG on 14/11/26.
*/
describe(&apos;hello world&apos;, function () {
  it(&apos;should contains world&apos;, function () {
    expect(&apos;Hello world&apos;).toContain(&apos;world&apos;);
  });
});
</code></pre><p>上面测试用例用的是Jasmine语法。Jasmine是一个专为JavaScript代码测试的行为驱动开发框架。它不依赖其它的JavaScript框架，不需要DOM。并且它有一个整洁明朗，一目了然的语法，让你能够简单地写测试用例。详细说明与语法介绍请<a href="http://jasmine.github.io/edge/introduction.html" target="_blank" rel="external">戳此</a>。</p>
<p>打开<code>my.conf.js</code>，修改files配置如下：</p>
<pre><code>// list of files / patterns to load in the browser
files: [
  &apos;test/*Spec.js&apos;
],
</code></pre><p>启动Karma测试环境：</p>
<p><img src="http://ww3.sinaimg.cn/large/4da583a7jw1emok4chz8rj21960mydko.jpg" alt="启动成功"><br>开启你的Karma测试之旅！</p>
<p>###参考</p>
<ol>
<li><a href="http://karma-runner.github.io/0.12/index.html" target="_blank" rel="external">Karma官网</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发软件的过程中，进行单元测试是非常不错的工作，也是有必要的工作。它帮助你觉得你的代码是无懈可击的，确保产品的可靠性。作为一名追求进步的的前端码农，学习前端的测试很有必要。&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="Karma" scheme="http://yoursite.com/tags/Karma/"/>
    
      <category term="Test" scheme="http://yoursite.com/tags/Test/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】分析JavaScript性能</title>
    <link href="http://yoursite.com/2014/11/01/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91%E5%88%86%E6%9E%90JavaScript%E6%80%A7%E8%83%BD/"/>
    <id>http://yoursite.com/2014/11/01/【翻译】分析JavaScript性能/</id>
    <published>2014-11-01T07:48:54.000Z</published>
    <updated>2016-03-28T12:58:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>###JavaScript分析数据图表介绍</p>
<p>使用谷歌Chrome浏览器，打开V8测试套件页面，点击<code>开始分析</code>按钮或者按<span class="kbd">Cmd</span>＋<span class="kbd">E</span>快捷键开始记录JavascriptCPU分析。现在，刷新V8测试套件页面。</p>
<a id="more"></a>
<p>当页面重新加载完毕，一个基准测试结果的评分将会出现。回到DevTools，点击<code>停止</code>按钮或者再次按<span class="kbd">Cmd</span>＋<span class="kbd">E</span>快捷键来停止记录。</p>
<p><img src="http://ww3.sinaimg.cn/bmiddle/4da583a7jw1elvixmb7mpj213k0jedlg.jpg" alt="image"></p>
<p>上图的<code>Bottom Up</code>视图列出了影响性能的函数，它也能够用来检查这些函数的调用路径。</p>
<p>现在，通过点击Bottom Up / Top Down选择按钮来选择<code>Top Down</code>视图，然后点击函数列左边的小箭头，<code>Top Down</code>视图展示了一个调用结构的总体情况，从调用栈的顶部开始。</p>
<p>在函数列中选择一个函数，然后点击<code>Focus selected function</code>按钮(眼睛图标)。</p>
<p><img src="http://ww4.sinaimg.cn/bmiddle/4da583a7jw1elvixjoqxjj213y0di41n.jpg" alt=""></p>
<p>这将过滤分析结果，只展示选中的函数和它的调用程序。点击<code>Reload</code>按钮（刷新图标）来恢复分析及过的原始状态。</p>
<p>选择函数列中的一个函数，然后点击<code>Exclude selected function</code>按钮（X图标）。根据你选择的函数，你会看到类似如下图片的东西：</p>
<p><img src="http://ww3.sinaimg.cn/bmiddle/4da583a7jw1elvj2itu8bj213q0dmadj.jpg" alt=""></p>
<p><code>Exclude selected function</code>按钮的作用是从分析结果中移除选中的函数，然后计算排除之前函数后，调用函数的总时间。点击<code>Reload</code>按钮（刷新图标）来恢复分析及过的原始状态。</p>
<p>你可以记录多份分析数据图表。点击<code>开始分析</code>按钮，重新载入V8基准测试页面，然后点击<code>停止分析</code>按钮。</p>
<p><img src="http://ww3.sinaimg.cn/bmiddle/4da583a7jw1elvj2fwicoj21fy0dodkz.jpg" alt=""></p>
<p>左侧的侧边栏列出了你记录的分析数据图表，右边的树形视图展示了选中的分析数据图表的信息集。</p>
<p>###使用烈焰图</p>
<p>烈焰图视图提供了一个JavaScript执行过程的可视化表示，和<code>Timeline</code>与<code>Network</code>展示的相似。执行完一个JavaScriptCPU数据分析后，通过详细视图中的烈焰图的功能，你可以以另一种方式来查看分析数据图表的数据。</p>
<p>#####可视化执行路径</p>
<p>通过分析和理解函数调用进程，你能够对你的应用的执行路径在视觉上得到一个更好的理解。</p>
<p><img src="http://ww3.sinaimg.cn/bmiddle/4da583a7jw1elvix6271vj21400g7aei.jpg" alt=""></p>
<p>#####通过颜色码识别异常值<br>当缩小烈焰图，你可以识别出能够优化的重复图样，或者更重要的，你能够更加轻易地识别出异常值或者意想不到的执行过程。</p>
<p><img src="http://ww1.sinaimg.cn/bmiddle/4da583a7jw1elvix3jzvmj20sg0b0gni.jpg" alt=""></p>
<p>#####时间量度(类似时间轴)上的可视化JavaScript分析数据<br>其它的JavaScript分析结果的数据是随着时间推移的累积，而烈焰图的报告数据是按时间显示的。这表明当你看到时间发生的时候，你就能跳进他们的时间量度里面，获取一些JavaScript执行过程的概览。举个例子，当你看到时间轴上黄色大条纹，这是一个能够查看问题的完美方法。</p>
<p><img src="http://ww3.sinaimg.cn/bmiddle/4da583a7jw1elvix9n1tij21400nen2v.jpg" alt=""></p>
<p>也许你甚至想要在记录JavaScript分析数据的同时，也做一个时间轴记录，这里有一个样例你可以这么做：</p>
<pre><code>(function() {
  console.timeline();
  console.profile();
  setTimeout(function() {
      console.timelineEnd();
      console.profileEnd();
  }, 3000);
})();
</code></pre><blockquote>
<p><strong>注意</strong>：水平轴表示时间，垂直轴是调用栈。耗性能的函数会显得很宽。调用栈在Y轴上表示，所以一个高的火焰图是不必关心的，请密切关注宽敞的柱状图，无论它们在调用栈的哪个位置。</p>
</blockquote>
<p>######如何使用烈焰图:</p>
<ol>
<li>打开DevTools，到Profiles面板。</li>
<li>选择Record JavaScript CPU profile选项然后点击开始按钮。</li>
<li>当你已经做完数据选择，点击停止按钮。</li>
</ol>
<p>在分析数据视图，从选择菜单中选择可视化的烈焰图。<br><img src="http://ww4.sinaimg.cn/bmiddle/4da583a7jw1elvixbgdryj20h60a1dgr.jpg" alt=""></p>
<blockquote>
<p><strong>注意</strong>：为了提高记录分析数据的准确性，请在DevTools的设置面板中勾选<em>High resolution CPU profiling</em>的选项，之后，你就能够以十分之一毫秒的度量来查看烈焰图的数据。</p>
</blockquote>
<p>面板的顶部展示了整个记录过程的概观。你可以用鼠标选择指定区域，并放大这个区域。你也可以通过点击空白区域和拖动你的鼠标来向左右滚动。详细视图的时间量度会相应的伸缩。</p>
<p><img src="http://ww1.sinaimg.cn/bmiddle/4da583a7jw1elvixe8hpej20h609d0u5.jpg" alt=""></p>
<p>在详细视图中，函数的调用栈被表示为一个堆栈块。处于上面的块是被处在下面的函数块调用。鼠标悬浮在一个函数快上面将会显示函数名和耗时数据：</p>
<p><img src="http://ww1.sinaimg.cn/bmiddle/4da583a7jw1elvixfnoeuj209y07gaaf.jpg" alt=""></p>
<ul>
<li><strong>Name</strong>－函数的名称。</li>
<li><strong>Self time</strong>－函数完成当前调用的时间，只包括函数本身的语句，不包括它调用的其它函数的时间。</li>
<li><strong>Total time</strong>－函数完成调用的时间，包括它调用的其它函数的时间。</li>
<li><strong>Aggregated self time</strong>－整个记录过程中，函数调用的总时间，不包括该函数调用其它函数的时间。</li>
<li><strong>Aggregated total time</strong>－函数调用的总时间，包括该函数调用其它函数的时间</li>
</ul>
<p>烈焰图上的颜色是随机的，然而在整个调用过程中函数的颜色都会一致的。这让你能够轻易地查看函数的执行过程，认出异常值。时间轴上颜色的使用跟函数消耗资源是无关联的。</p>
<p><img src="http://ww4.sinaimg.cn/bmiddle/4da583a7jw1elvixh49baj20ag030jrf.jpg" alt=""></p>
<p>点击函数块能够在Sources面板中打开包含它的JavaScript文件，调转到函数定义的行。</p>
<p><a href="https://developer.chrome.com/devtools/docs/cpu-profiling" target="_blank" rel="external">原文地址</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###JavaScript分析数据图表介绍&lt;/p&gt;
&lt;p&gt;使用谷歌Chrome浏览器，打开V8测试套件页面，点击&lt;code&gt;开始分析&lt;/code&gt;按钮或者按&lt;span class=&quot;kbd&quot;&gt;Cmd&lt;/span&gt;＋&lt;span class=&quot;kbd&quot;&gt;E&lt;/span&gt;快捷键开始记录JavascriptCPU分析。现在，刷新V8测试套件页面。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Chrome DevTools" scheme="http://yoursite.com/tags/Chrome-DevTools/"/>
    
      <category term="JavaScript Performance" scheme="http://yoursite.com/tags/JavaScript-Performance/"/>
    
  </entry>
  
  <entry>
    <title>Angularjs自定义指令小试</title>
    <link href="http://yoursite.com/2014/10/26/Angularjs%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E5%B0%8F%E8%AF%95/"/>
    <id>http://yoursite.com/2014/10/26/Angularjs自定义指令小试/</id>
    <published>2014-10-26T14:39:54.000Z</published>
    <updated>2016-03-28T12:58:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>##简介<br>指令（Directives）是Angularjs非常强大的属性之一，使用指令可以创建很多共用的组建，用于减轻代码的重复性和实现复杂逻辑。</p>
<a id="more"></a>
<p>指令标记在一个DOM元素上（例如一个属性、一个元素名称、注释或者CSS类），告诉Angularjs的HTML编译器（$compile）将指定的行为附加到DOM元素上或者甚至转换DOM元素和它的子元素。</p>
<p>Angular附带了一系列内建的指令，例如<code>ngBind</code>、<code>ngModel</code>和<code>ngClass</code>，就像你创建控制器和服务，你可以为Angular创建自己的指令来使用。当Angular引导你的应用时，HTML编译器会遍历DOM元素来匹配DOM对应的指令。</p>
<p>下面简单实现一个年月日下拉框联动选择的Angular自定义指令。</p>
<p>##声明指令<br>Angular使用<code>directive()</code>这个方法来定义指令：</p>
<pre><code>angular.module(&apos;myApp&apos;,[])
    .directive(&apos;myDirective&apos;,function(){
        //定义指令的内容
    });
</code></pre><p><code>directive()</code>方法接受两个参数：</p>
<ol>
<li>name（字符串）。指令的名称。</li>
<li>factory_function。该函数返回一个定义了指令的全部行为的对象。</li>
</ol>
<p>当Angular启动应用的时候，会把第一个参数作为名称来注册第二个参数返回的对象。Angular会解析DOM元素中使用这个名称的地方，并在这个地方引用对应的指令。</p>
<pre><code>&lt;div my-directive&gt;&lt;/div&gt;
</code></pre><p><code>注意</code>：定义的指令名称为驼峰式的字符串，但是使用的时候要用横杆替换。</p>
<p>##指令的配置项</p>
<p>本例子使用到的指令配置项如下</p>
<p>####restrict</p>
<p>restrict是一个可选的参数，它告诉Angular该指令在DOM中可以以何种形式被声明。默认值为<code>A</code>，即以属性的形式来进行声明。该配置项的可选值如下：</p>
<pre><code>E（元素）
&lt;my-directive&gt;&lt;/my-directive&gt;
A（属性，默认值）
&lt;div my-directive&gt;&lt;/div&gt;
C（类名）
&lt;div class=&quot;my-directive&quot;&gt;&lt;/div&gt;
M（注释）
&lt;!--directive:my-directive--&gt;
</code></pre><p>以上可选值可以独立使用，也可以混合使用。但是请注意，如果目标网页应用有兼容低版本IE浏览器的需求时，请勿只使用<code>E</code>选项，明智点的方法是同时使用<code>EA</code>选项。</p>
<p>####replace</p>
<p>replace是一个可选的参数，如果设置了其值必须是true，因为默认值就是false。默认值表示指令中定义的模板会被当作自元素插入到调用此指令的元素内部。</p>
<pre><code>&lt;div my-directive&gt;&lt;/div&gt;
.directive(&apos;myDirective&apos;,function(){
    return {
        template: &apos;&lt;div&gt;Some stuff here&lt;/div&gt;&apos;
    }
});

调用结果如下
&lt;div my-directive&gt;
    &lt;div&gt;Some stuff here&lt;/div&gt;
&lt;/div&gt;
</code></pre><p>当replace的值设为true的时候</p>
<pre><code>.directive(&apos;myDirective&apos;,function(){
    return {
        replace: true,
        template: &apos;&lt;div&gt;Some stuff here&lt;/div&gt;&apos;
    }
});

结果如下
&lt;div&gt;Some stuff here&lt;/div&gt;
</code></pre><p>####scope<br>该选项用于设置指令的作用域信息。选项可以被设为true或者一个对象。默认值为false。</p>
<p>当选项被设成true的时候，表示会从父作用域继承并创建一个新的作用域对象。</p>
<p>scope的选项也可以是一个空对象，这表示隔离作用域。隔离作用域是scope三个选项中最难理解的一个，但也是最强大的。楼主能力有限，并且本例子不使用该选项，所以在此略过。</p>
<p>scope的最后一个选项是绑定策略。Angular提供了几种方法能够将指令内部的隔离作用域同指令外部的作用域进行绑定。</p>
<pre><code>本地作用域属性：@ or @attr。将本地作用域同DOM属性的值绑定，指令内部作用域可以使用外部作用域的变量。
双向绑定：= or =attr。将本地作用域上的属性同父级作用域上的属性进行双向数据绑定。
父级作用域绑定：&amp; or &amp;attr。对父级作用域进行绑定，以便在指令作用域中运行函数。对这个值进行设置时会声称一个指向父级作用域的包装函数。
</code></pre><p>####controller<br>该选项表示指令的控制器，用来控制指令的逻辑行为。控制器中有一些特殊的服务可以被注入到指令当中</p>
<ol>
<li>$scope。与指令相关联的当前作用域。</li>
<li>$element。当前指令对应的元素。</li>
<li>$attrs。 当前元素的属性组成的对象。</li>
<li>$transclude。嵌入连接函数会与对应的嵌入作用域进行预绑定。</li>
</ol>
<p>####template<br>该选项可选值如下：</p>
<ol>
<li>一段HTML文本。</li>
<li>可以接受两个参数，参数为tElement和tAttrs，并返回一个代表模板的字符串。</li>
</ol>
<p>##逻辑<br>年月日下拉框联动选择的Angular自定义指令目标是创建三个下拉框，第一个表示年份，第二个表示月份，第三个表示日期，年月日下拉框必须能够联动，并且当选择闰年的二月份的时候，日下拉框必须有29的选项。同时该指令能够将选择的结果返回给父作用域。</p>
<p>年月日下拉框联动选择（以下简称qbDate）指令的模板如下：</p>
<pre><code>template: &apos;\
      &lt;div&gt;\
        &lt;select ng-model=&quot;year&quot;&gt;\
            &lt;option value=&quot;&quot;&gt;&lt;/option&gt;\
            &lt;option ng-repeat=&quot;item in yearList&quot; value=&quot;{{item}}&quot;&gt;{{item}}&lt;/option&gt;\
        &lt;/select&gt;\
        &lt;select ng-model=&quot;month&quot;&gt;\
            &lt;option value=&quot;&quot;&gt;&lt;/option&gt;\
            &lt;option ng-repeat=&quot;item in monthList track by $index&quot; value=&quot;{{item}}&quot;&gt;{{item}}&lt;/option&gt;\
        &lt;/select&gt;\
        &lt;select ng-model=&quot;day&quot;&gt;\
            &lt;option&gt;&lt;/option&gt;\
            &lt;option ng-repeat=&quot;item in dayList track by $index&quot; value=&quot;{{item}}&quot;&gt;{{item}}&lt;/option&gt;\
        &lt;/select&gt;\
      &lt;/div&gt;\
    &apos;
</code></pre><p>qbDate的控制器逻辑代码如下</p>
<pre><code>controller: function($scope,$element){
    console.log($scope.year,$scope.month,$scope.day);
    $scope.yearList = [];
    for(var i = 1900;i&lt;=2030;i++){
        $scope.yearList.push(i);
    }
    $scope.monthList = [];
    $scope.dayList = [];
    for(var i = 1;i&lt;=12;i++){
        $scope.monthList.push(i);
    }
    $scope.$watch(&apos;year&apos;,function(newValue,oldValue){
        if(newValue){
            if(newValue.length &gt; 4){
                $scope.year = oldValue;
            }
            $scope.dayList = [];
            $scope.month = &apos;&apos;;
            $scope.day = &apos;&apos;;

        }

    });
    $scope.$watch(&apos;month&apos;,function(newValue,oldValue){
        var months31 = [1,3,5,7,8,10,12];
        var months30 = [4,6,9,11];
        var month = parseInt(newValue);
        var maxDay = 31;
        if(months31.indexOf(month) &gt; 0){
            maxDay = 31;
        } else if (months30.indexOf(month) &gt; 0){
            maxDay = 30;
        } else{
            var year = parseInt($scope.year);
            if((year%4==0 &amp;&amp; year%100!=0)||(year%100==0 &amp;&amp; year%400==0)){
                maxDay=29;
            }else{
                maxDay=28;
            }
        }
        for(var i = 1;i&lt;=maxDay;i++){
            $scope.dayList.push(i);
        }
    });
},
</code></pre><p>qbDate的作用域设置如下</p>
<pre><code>scope: {
        year: &apos;=yearModel&apos;,
        month: &apos;=monthModel&apos;,
        day: &apos;=dayModel&apos;
    },
</code></pre><p>使用的时候这么用：</p>
<pre><code>&lt;div qb-date year-model=&quot;year&quot; month-model=&quot;month&quot; day-model=&quot;day&quot;&gt;&lt;div&gt;
</code></pre><p>结合qbDate的作用域设置详情，qbDate 的作用域里面的year属性将绑定到qbDate指令的属性yearModel，而yearModel的值为qbDate指令父作用域year的值。由于qbDate指令是双向绑定的，所以指令内部的值变化将会反应到父作用域的值变化。</p>
<p>##源码<br>本例子源码已经放在<a href="http://jsfiddle.net/fnghwsj/p3x9ufhe/3/" target="_blank" rel="external">JSFiddle</a>上。</p>
<p>仓促赶工，如有谬误，还望指正。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##简介&lt;br&gt;指令（Directives）是Angularjs非常强大的属性之一，使用指令可以创建很多共用的组建，用于减轻代码的重复性和实现复杂逻辑。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AngularJS" scheme="http://yoursite.com/tags/AngularJS/"/>
    
      <category term="Directives" scheme="http://yoursite.com/tags/Directives/"/>
    
  </entry>
  
  <entry>
    <title>AngularJS动态路由</title>
    <link href="http://yoursite.com/2014/08/02/AngularJS%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/"/>
    <id>http://yoursite.com/2014/08/02/AngularJS动态路由/</id>
    <published>2014-08-02T07:49:48.000Z</published>
    <updated>2016-03-28T12:58:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>##前言</p>
<blockquote>
<p>AngularJS是一款开源 JavaScript函式库，由Google维护，用来协助单一页面应用程式运行的。它的目标是透过MVC模式 (MVC) 功能增强基于浏览器的应用，使开发和测试变得更加容易</p>
</blockquote>
<a id="more"></a>
<p>本例子使用的是AngularJS 1.2.2版本。</p>
<p>##简单的动态路由<br>AngularJS提供动态路由控制，就是根据地址栏链接不同调用不同的模板来呈现在页面。<br>使用动态路由需要调用<a href="https://docs.angularjs.org/api/ngRoute" target="_blank" rel="external">ngRoute</a>模块,ngRoute模块为angular应用提供了路由选择、深链接服务和指令。</p>
<p>####安装<br>在主页面（一般是index.html页面）引用如下两个js文件</p>
<pre><code>&lt;script src=&quot;angular.js&quot;&gt;
&lt;script src=&quot;angular-route.js&quot;&gt;
</code></pre><p>####路由选择定义<br>创建一个app.js文件：</p>
<pre><code>/**
 * Created by Arthur WANG on 14-8-2.
 */
var app = angular.module(&apos;app&apos;, [&apos;ngRoute&apos;]);//创建名为app的模块

//配置动态路由
app.config([&apos;$routeProvider&apos;, function ($routeProvider) {
    $routeProvider
        .when(&apos;/about&apos;, {//当解析到/about路径的时候，会调用viws/about.html模板和使用aboutCtrl控制器
            templateUrl: &apos;views/about.html&apos;,
            controller: &apos;aboutCtrl&apos;
        })
        .when(&apos;/contact&apos;, {
            templateUrl: &apos;views/contact.html&apos;,
            controller: &apos;contactCtrl&apos;
        }).otherwise({//其他路径时跳转到主页
            redirectTo: &apos;/&apos;
        });
}]);
</code></pre><p>在主页面中引用以上js文件。</p>
<p>####控制器<br>这里，我们打算进入about页面时调用aboutCtrl控制器。所以我们创建一个aboutCtrl.js，如下所示：<br>    /**</p>
<pre><code> * Created by Arthur WANG on 14-8-2.
 */
app.controller(&apos;aboutCtrl&apos;, [&apos;$scope&apos;, function ($scope) {
    $scope.author = &quot;Arthur WANG&quot;;
    $scope.name = &quot;AngularJS&quot;;
}]);
</code></pre><p>####视图<br>路径<code>/about</code>将会调用<code>views/about.html</code>，在视图里面填上要呈现的内容。</p>
<p>####主页面<br>在主页面里，依次引用上面写的js文件</p>
<pre><code>&lt;script src=&quot;app.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;controllers/aboutCtrl.js&quot;&gt;&lt;/script&gt;
</code></pre><p>同时，建议将<code>ng-app=”app”</code>指令放置在<code>&lt;html&gt;</code>标签上。<br>然后在需要动态替换视图的地方添加如下代码：</p>
<pre><code>&lt;!--Div.ng-view将会被模板替换--&gt;
&lt;div ng-view&gt;&lt;/div&gt;
</code></pre><p>这样，一个简单的AngularJS动态路由就搭建完毕。</p>
<p>##随路由改变而变化的页面标题</p>
<p>如果想要路由变化的时候，页面title也跟着变化，可以如下设置：</p>
<p>1、 为每个$routeProvider的条件添加title属性:</p>
<pre><code>$routeProvider
    .when(&apos;/about&apos;, {//当解析到/about路径的时候，会调用viws/about.html模板和使用aboutCtrl控制器
        title: &apos;关于&apos;,
        templateUrl: &apos;views/about.html&apos;,
        controller: &apos;aboutCtrl&apos;
    })
    .otherwise({
        title: &apos;首页&apos;,
        redirectTo: &apos;/&apos;
    });
</code></pre><p>2、 在app.js的后面添加如下代码：</p>
<pre><code>//页面title跟着变化
app.run([&apos;$location&apos;,&apos;$rootScope&apos;,function($location,$rootScope){
    $rootScope.$on(&apos;$routeChangeSuccess&apos;, function (event, current, previous) {
        $rootScope.title = current.title;
    });
}]);
</code></pre><p>3、 主页面的title修改为如下：</p>
<pre><code>&lt;title ng-bind=&quot;&apos;AngularJS&amp;mdash;&apos; + title&quot;&gt;&lt;/title&gt;
</code></pre><p>在这里，请注意，必须把<code>ng-app</code>指令设置到<code>&lt;html&gt;</code>标签处，这样子AngularJS才会将这个页面解析出来。</p>
<p>##One route,many views</p>
<p>以上的例子是一个路由对应一个视图，在这种情况下，如果有许多路由和视图，就得在<code>app.js</code>里面配置很多路由条件，每次新增一个路由视图的时候都得配置路由条件。</p>
<p>其实，<a href="http://www.github.com" target="_blank" rel="external">Github</a>上有位<a href="https://github.com/GrumpyWizards" target="_blank" rel="external">牛人</a>另辟蹊径，整出了一个<code>One route,many views</code>的例子，详情请移步<a href="https://github.com/GrumpyWizards/ngDynamicRouting" target="_blank" rel="external">ngDynamicRouting</a>项目。</p>
<p><code>ps</code>:本示例已经放在Github上，地址为<a href="https://github.com/wonsikin/ngDynamicRoutingDEMO" target="_blank" rel="external">ngDynamicRoutingDEMO</a>，欢迎指正。</p>
<p>##参考</p>
<ol>
<li><a href="http://www.ituring.com.cn/article/38394" target="_blank" rel="external">常见前端MVC框架比较</a></li>
<li><a href="http://angularjs.org" target="_blank" rel="external">AngularJS官网</a>，建议翻墙看</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##前言&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;AngularJS是一款开源 JavaScript函式库，由Google维护，用来协助单一页面应用程式运行的。它的目标是透过MVC模式 (MVC) 功能增强基于浏览器的应用，使开发和测试变得更加容易&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="AngularJS" scheme="http://yoursite.com/tags/AngularJS/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="MVC" scheme="http://yoursite.com/tags/MVC/"/>
    
  </entry>
  
  <entry>
    <title>Git与远程资源库同步简析</title>
    <link href="http://yoursite.com/2014/07/24/Git%E4%B8%8E%E8%BF%9C%E7%A8%8B%E8%B5%84%E6%BA%90%E5%BA%93%E5%90%8C%E6%AD%A5%E7%AE%80%E6%9E%90/"/>
    <id>http://yoursite.com/2014/07/24/Git与远程资源库同步简析/</id>
    <published>2014-07-24T11:06:31.000Z</published>
    <updated>2016-03-28T12:58:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>目前，我参与的公司的一个项目把版本控制放到Github上了。多人协作开发的工程中，需要时常从服务器上更新代码。Git中有两种更新代码的方法：<code>fetch</code>和<code>pull</code>。<br><a id="more"></a></p>
<p>###fetch 和 pull的区别<br>1.<code>git fetch</code>:从远程获取最新版本，不会自动merge。</p>
<pre><code>git fetch origin master #从远程获取最新版本
git log -p master..origin/master #比较本地与远程的差别
git merge origin/master #合并
</code></pre><p>2.<code>git pull</code>:从远程获取最新版本，并且自动合并</p>
<pre><code>git pull origin master
</code></pre><p>上述两种方法中，<code>git fetch</code>比较安全，能够在合并之前查看本地与远程的区别。<br>使用<code>git pull</code>的话，有的时候会因为本地有改动而执行失败。</p>
<p>###git stash<br>如果要获取最新版本的时候本地已经有改动了，而且这些改动是有意义的，怎么办呢？</p>
<p>可以使用<code>git stash</code>暂时搁置当前已做的改动。具体如下</p>
<p>1、先把本地改动加到staging area:</p>
<pre><code>git add .
</code></pre><p>2、将改动搁置:</p>
<pre><code>git stash
</code></pre><p>3、找回之前搁置的改动:</p>
<pre><code>git stash apply
</code></pre><p>4、查看所有的搁置版本:</p>
<pre><code>git stash list
</code></pre><p>5、stash的其他用法还有如下:</p>
<pre><code>git stash apply stash@{1} #找回栈中的第二个
git stash pop #找回第一个
git stash drop &lt;id&gt; #删除一个stash
git stash clear #删除所有stash
</code></pre><p>###参考</p>
<ol>
<li><a href="http://blog.csdn.net/hudashi/article/details/7664457" target="_blank" rel="external">http://blog.csdn.net/hudashi/article/details/7664457</a></li>
<li><a href="http://blog.csdn.net/qinjienj/article/details/7475890" target="_blank" rel="external">http://blog.csdn.net/qinjienj/article/details/7475890</a></li>
<li><a href="http://www.bootcss.com/p/git-guide/" target="_blank" rel="external">Git建议指南</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前，我参与的公司的一个项目把版本控制放到Github上了。多人协作开发的工程中，需要时常从服务器上更新代码。Git中有两种更新代码的方法：&lt;code&gt;fetch&lt;/code&gt;和&lt;code&gt;pull&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】PHP和node.js对比</title>
    <link href="http://yoursite.com/2014/07/12/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91php%E5%92%8Cnodejs%E5%AF%B9%E6%AF%94/"/>
    <id>http://yoursite.com/2014/07/12/【翻译】php和nodejs对比/</id>
    <published>2014-07-12T10:45:56.000Z</published>
    <updated>2016-03-28T12:58:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>当提到Web编程，在我大部分的时间里，我都是使用ASP.NET或者LAMP技术。现在，一种新的技术叫做node.js。它是一种轻量级的开发平台，在服务端运行Javascript代码，据说通过异步I/O方法提高性能。<br><a id="more"></a><br>新理论认为同步或者阻塞性I/O工作像如下所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/4da583a7tw1eia784efdpj20e209u74t.jpg" alt=""></p>
<p>I/O是Web事务中非常典型的高代价的部分。当一个请求到达Apache Web服务器的时候，服务器将请求传给PHP解释器解析成任何动态内容。现在，棘手的问题来了—假使PHP解析想要从磁盘或者数据库读取一些内容或者写一些内容，那会是整条链子上最慢的一环。当你调用PHP函数<code>file_get_contents()</code>的时候，服务器全部的线程都会被阻塞，直到内容被取回。服务器将不能做任何事情直到你的脚本拿到文件内容。考虑下同时从不同用户那里发起许多类似请求到你的服务器的时候将会发生什么？他们会因为线程阻塞在I/O中，服务器没有任何线程可以用来处理任务而处在等待的队列中！</p>
<p>node.js提出了一个独特的卖点。因为node.js在它几乎所有的函数中实现异步I/O。在上面描述的场景中，服务器中的线程将会在文件检索函数（<code>fs.readFile</code>）被调用后立马被释放。然后，一旦I/O读写完毕，node就会调用一个函数（早前从<code>fs.readFile</code>传递过来的）传递数据参数。同一时刻，珍贵的线程能被用来服务其它线程。</p>
<p>这就是关于node.js的理论。但是在猿工界，我不是一个能够接受新事物的人，因为node.js被吹得天花乱坠而且每个人都在用它。不，我要自己查明和验证node.js的真实情况。我想看看这个理论是否能够经受实践检验。</p>
<p>所以我给自己定的工作就是写两个相同的脚本来进行基准测试：一个使用PHP（发布在Apache2上），另一个使用Javascript（发布在node.js上）。测试非常简单，脚本要实现的目标如下：</p>
<ol>
<li>接收请求。</li>
<li>生成一串大小为108kb的随机字符串。</li>
<li>将字符串写在磁盘上的一个文件中。</li>
<li>然后从磁盘中读回内容。</li>
<li>在响应流中返回字符串。</li>
</ol>
<p>这是第一个脚本，<code>index.php</code>:</p>
<pre><code>&lt;?php
    //index.php
    $s=&quot;&quot;; //generate a random string of 108KB and a random filename
    $fname = chr(rand(0,57)+65).chr(rand(0,57)+65).chr(rand(0,57)+65).chr(rand(0,57)+65).&apos;.txt&apos;;
    for($i=0;$i&lt;108000;$i++)
    {
        $n=rand(0,57)+65;
        $s = $s.chr($n);
    }

    //write s to a file
    file_put_contents($fname,$s);
    $result = file_get_contents($fname);
    echo $result;
?&gt;
</code></pre><p>然后这是第二个脚本，<code>server.js</code>:</p>
<pre><code>//server.js
var http = require(&apos;http&apos;);
var server = http.createServer(handler);

function handler(request, response) {
    //console.log(&apos;request received!&apos;);
    response.writeHead(200, {&apos;Content-Type&apos;: &apos;text/plain&apos;});

    s=&quot;&quot;; //generate a random string of 108KB and a random filename
    fname = String.fromCharCode(Math.floor(65 + (Math.random()*(122-65)) )) +
        String.fromCharCode(Math.floor(65 + (Math.random()*(122-65)) )) +
        String.fromCharCode(Math.floor(65 + (Math.random()*(122-65)) )) +
        String.fromCharCode(Math.floor(65 + (Math.random()*(122-65)) )) + &quot;.txt&quot;;

    for(i=0;i&lt;108000;i++)
    {
        n=Math.floor(65 + (Math.random()*(122-65)) );
        s+=String.fromCharCode(n);
    }

    //write s to a file
    var fs = require(&apos;fs&apos;);
    fs.writeFile(fname, s, function(err, fd) {
            if (err) throw err;
            //console.log(&quot;The file was saved!&quot;);
            //read back from the file
            fs.readFile(fname, function (err, data) {
                if (err) throw err;
                result = data;
                response.end(result);
            });
        }
    );
}

server.listen(8124);
console.log(&apos;Server running at http://127.0.0.1:8124/&apos;);
</code></pre><p>接着运行Apache基准测试工具，给两个脚本发起2000次请求（200个并发）。当我看到运行结束的时间统计数据，我和我的小伙伴都惊呆了：</p>
<pre><code>#PHP:
Concurrency Level:      200
Time taken for tests:   574.796 seconds
Complete requests:      2000

#node.js:
Concurrency Level:      200
Time taken for tests:   41.887 seconds
Complete requests:      2000
</code></pre><p>真相大白。node.js比PHP快了十四倍多！这个结果是令人惊讶的，它简明地意味着在不久的将来，node.js将会成为编写性能驱动的应用的事实标准，这是毫无疑问的！</p>
<p>我同意node.js的生态系统还没有广泛地发展，很多用来数据库连接、网络接入、工具类node模块正在积极地开发中。但是尽管如此，在看到这个结果之后，我们无须担心。任何花在node.js开发上的额外努力都是值得的。PHP也许仍然能保有“Web之王”的地位，但是随着node.js的到来，我觉得那种情况不会持续很长时间。</p>
<p>####参考</p>
<ol>
<li><a href="https://en.wikipedia.org/wiki/Node.js" title="https://en.wikipedia.org/wiki/Node.js" target="_blank" rel="external">https://en.wikipedia.org/wiki/Node.js</a></li>
<li><a href="http://notes.ericjiang.com/posts/751" title="http://notes.ericjiang.com/posts/751" target="_blank" rel="external">http://notes.ericjiang.com/posts/751</a></li>
<li><a href="http://nodejs.org" target="_blank" rel="external">http://nodejs.org</a></li>
<li><a href="https://code.google.com/p/node-js-vs-apache-php-benchmark/wiki/Tests" target="_blank" rel="external">https://code.google.com/p/node-js-vs-apache-php-benchmark/wiki/Tests</a></li>
</ol>
<p>####原文信息<br>链接：<a href="http://www.prahladyeri.com/2014/06/php-vs-node-js-real-statistics/" target="_blank" rel="external">PHP vs node.js: The REAL statistics</a></p>
<p>作者：Prahlad Yeri</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当提到Web编程，在我大部分的时间里，我都是使用ASP.NET或者LAMP技术。现在，一种新的技术叫做node.js。它是一种轻量级的开发平台，在服务端运行Javascript代码，据说通过异步I/O方法提高性能。&lt;br&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="http://yoursite.com/tags/Node-js/"/>
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Spring MVC注解小例子</title>
    <link href="http://yoursite.com/2014/06/19/spring-mvc%E6%B3%A8%E8%A7%A3%E5%B0%8F%E4%BE%8B%E5%AD%90/"/>
    <id>http://yoursite.com/2014/06/19/spring-mvc注解小例子/</id>
    <published>2014-06-19T07:07:57.000Z</published>
    <updated>2016-03-28T12:58:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>##前言<br>本文将用注解的形式实现Spring MVC的功能。对于Spring MVC的入门，可以参考本人的前一篇博文。作为一位程序猿界的新人，如有谬误，欢迎指正。</p>
<a id="more"></a>
<p>##引用jar包<br>在项目中引用如下jar包：</p>
<pre><code>.
├──lib
|  ├── commons-logging-1.0.4.jar
|  ├── spring-aop.jar
|  ├── spring-beans.jar
|  ├── spring-context.jar
|  ├── spring-context-support.jar
|  ├── spring-core.jar
|  ├── spring-expression.jar
|  ├── spring-web.jar
|  ├── spring-webmvc.jar
</code></pre><p>##web.xml配置<br>本例子中，我们使用自定义的配置文件，拦截规则是<code>/</code>。</p>
<pre><code>&lt;servlet&gt;
    &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;!-- 这里指定配置文件为WEB-INF下面的springMVC.xml --&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;/WEB-INF/springMVC.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre><p>##springMVC.xml配置</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
  xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
  xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
  xsi:schemaLocation=&quot;  
    http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd  
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd&quot;&gt;

    &lt;context:component-scan base-package=&quot;com.wonsikin&quot; /&gt;

    &lt;mvc:annotation-driven /&gt;

    &lt;!-- 视图解释器 --&gt;
    &lt;bean id=&quot;viewResolver&quot;
        class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;viewClass&quot;
            value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;

    &lt;bean
        class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt;
        &lt;property name=&quot;messageConverters&quot;&gt;
            &lt;list&gt;
                &lt;bean
                    class=&quot;org.springframework.http.converter.ByteArrayHttpMessageConverter&quot; /&gt;

                &lt;bean
                    class=&quot;org.springframework.http.converter.ResourceHttpMessageConverter&quot; /&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre><p><code>&lt; context:component-scan base-package=”com.wonsikin” /&gt;</code>表示自动扫描的包名。</p>
<p><code>&lt; mvc:annotation-driven /&gt;</code>表示默认的注解映射的支持。如何替换 <code>&lt; mvc:annotation-driven /&gt;</code>？请参考<a href="http://elf8848.iteye.com/blog/875830/" target="_blank" rel="external">赵磊的博客</a>的第十九节。</p>
<p>##模型（Model）<br>创建一个登录用户的模型，如下：</p>
<pre><code>package com.wonsikin.view;

public class LoginUser {

    private String username;

    private String password;

    /**
    *getter,setter
    */
    ......

}
</code></pre><p>##控制器（Controller）</p>
<pre><code>package com.wonsikin.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;

import com.wonsikin.view.LoginUser;


@Controller
@RequestMapping(&quot;/wonsikin&quot;)
public class LoginController {

    @RequestMapping(&quot;/login&quot;)
    public ModelAndView login(@ModelAttribute LoginUser user) throws Exception {
        System.out.println(user.getUsername());
        return new ModelAndView(&quot;loginInfo&quot;,&quot;username&quot;,user.getUsername());
    }
}
</code></pre><p>注解<code>@Controller</code>声明该类为一个Action组件。</p>
<p>类名上面的注解<code>@RequestMapping(“/wonsikin”)</code>类似Struts2的命名空间（namespace），用来声明该类下的方法的父路径为<code>/wonsikin</code>。</p>
<p>方法上面的注解<code>@RequestMapping(“/login”)</code>表示调用该方法的路径。</p>
<p>方法中的参数的注解<code>@ModelAttribute</code>表示该前台传过来的参数会被自动解析成一个模型。类似Struts2的模型驱动。</p>
<p>一个控制器里面同时多个方法处理的情况跟这个差不多，无非就是多几个方法，多配置一些路径。在此不赘述。</p>
<p>##REST风格的路径<br>现在的互联网，REST风格非常流行，很多互联网类型的应用都很喜欢这样的URL。实现这样的功能需要一个注解<code>@PathVariable</code>。同时我们会比较另一个注解<code>@RequestParam</code>，因为这两个注解在功能上非常相似。</p>
<p><code>@RequestParam</code>用来获取路径中传过来的参数，也就是问号后面的参数。</p>
<p><code>@PathVariable</code>则是用来获取路径中的变量参数。</p>
<p>举个栗子：</p>
<pre><code>package com.wonsikin.controller;

import java.util.HashMap;
import java.util.Map;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.servlet.ModelAndView;


@Controller
@RequestMapping(&quot;/userCtl&quot;)
public class UserController {

    @RequestMapping(&quot;/{userId}/add&quot;)
    public ModelAndView add(@PathVariable String userId,@RequestParam String action){
        System.out.println(userId);
        System.out.println(action);
        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
        map.put(&quot;userId&quot;, userId);
        map.put(&quot;action&quot;, action);
        return new ModelAndView(&quot;variable&quot;,&quot;map&quot;,map);
    }
}
</code></pre><p>当我们向服务器发送请求如下请求时</p>
<pre><code>http://localhost:8081/SpringMVCAnnotation/userCtl/12345/add?action=add
</code></pre><p>后台截取到的变量分别是</p>
<pre><code>userId：12345
action：add
</code></pre><p>##静态文件的访问<br>由于我们的拦截规则是<code>/</code>，这就会导致一些静态文件无法获取到。只需在<code>springMVC.xml</code>中添加如下配置即可：</p>
<pre><code>&lt;!-- 允许对静态资源文件的访问 --&gt;
&lt;mvc:default-servlet-handler/&gt;
</code></pre><p>事实上，解决静态文件无法访问的方法有多种，详情可以参考<a href="http://elf8848.iteye.com/blog/875830/" target="_blank" rel="external">赵磊的博客</a>第七小节。</p>
<p>##结语<br>Spring的注解非常强大，用好注解能减轻我们配置XML的负担。</p>
<p>##参考</p>
<ol>
<li><a href="http://elf8848.iteye.com/blog/875830/" target="_blank" rel="external">赵磊的博客</a></li>
<li><a href="http://stackoverflow.com/questions/13715811/requestparam-vs-pathvariable" target="_blank" rel="external">StackOverflow上关于@RequestParam和@PathVariable区别的回答</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##前言&lt;br&gt;本文将用注解的形式实现Spring MVC的功能。对于Spring MVC的入门，可以参考本人的前一篇博文。作为一位程序猿界的新人，如有谬误，欢迎指正。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MVC" scheme="http://yoursite.com/tags/MVC/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="Java Web" scheme="http://yoursite.com/tags/Java-Web/"/>
    
      <category term="annotation" scheme="http://yoursite.com/tags/annotation/"/>
    
  </entry>
  
  <entry>
    <title>Spring MVC 简单例子</title>
    <link href="http://yoursite.com/2014/06/18/spring-mvc%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/"/>
    <id>http://yoursite.com/2014/06/18/spring-mvc简单例子/</id>
    <published>2014-06-18T07:37:07.000Z</published>
    <updated>2016-03-28T12:58:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>##简介<br>Spring自从创建以来，功能愈来愈丰富，从原本的依赖注入（DI）和面向切面编程（AOP）等简单功能发展成了具有MVC、ORM等功能的全能战士，大有一统江湖的态势。本文是个人的学习笔记，仅供参考。本人才疏学浅，如有谬误，还望指正，不胜感激涕零！<br><a id="more"></a></p>
<p>##创建项目<br>用Eclipse创建一个Web项目。本例子命名为SpringMVC。</p>
<p>##引用jar包<br>本例子使用的Spring版本是4.0.2。以下列出的jar包就只包含名字，不带版本号。</p>
<pre><code>.
├──lib
|  ├── commons-logging-1.0.4.jar
|  ├── spring-context.jar
|  ├── spring-context-support.jar
|  ├── spring-core.jar
|  ├── spring-expression.jar
|  ├── spring-web.jar
|  ├── spring-webmvc.jar
|  ├── spring-beans.jar
</code></pre><p>##web.xml配置<br>要使用Spring MVC，配置DispatcherServlet是第一步。它拦截我们自己定义的请求，依据我们定义的规则分发到目标Controller（既Action类）来处理。</p>
<p>例子1：</p>
<pre><code>&lt;servlet&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre><p><code><url-pattern>*.do</url-pattern></code>表示会拦截所有以do为后缀的请求。</p>
<p><code><servlet-name>springmvc</servlet-name></code>表示DispatcherServlet的名字是springmvc。DispatcherServlet可以有多个，通过名字来区别。</p>
<p>在DispatcherServlet的初始化过程中，框架会在web应用的<code>WEB-INF</code>文件夹下寻找名为<code>[servlet-name]-servlet.xml</code> 的配置文件，生成文件中定义的bean。</p>
<p>当然，你也可以自己指定配置文件名，不使用默认的配置文件名。如下：</p>
<pre><code>&lt;servlet&gt;  
    &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;  
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;  
    &lt;init-param&gt;  
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;  
        &lt;param-value&gt;classpath*:/springMVC.xml&lt;/param-value&gt;  
    &lt;/init-param&gt;  
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  
&lt;/servlet&gt;  
&lt;servlet-mapping&gt;  
    &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;  
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  
&lt;/servlet-mapping&gt;  
</code></pre><p>其中<code><param-value>**.xml</param-value></code>可以有多种配置写法：</p>
<ol>
<li>不写,使用默认值:/WEB-INF/<servlet-name>-servlet.xml</servlet-name></li>
<li><param-value>/WEB-INF/classes/springMVC.xml</param-value></li>
<li><param-value>classpath*:springMVC-mvc.xml</param-value></li>
<li>多个值用逗号分隔</li>
</ol>
<p><code>PS:</code>本例子使用的是默认的配置文件名。</p>
<p>##springmvc-servlet.xml配置<br>直接上代码：</p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;  
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd  
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&gt;

        &lt;!-- 视图解释器 --&gt;
        &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
            &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt;
            &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;
            &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;&lt;!--可为空,方便实现自已的依据扩展名来选择视图解释类的逻辑  --&gt;
        &lt;/bean&gt;

        &lt;!-- 控制器 --&gt;
        &lt;bean id=&quot;loginController&quot; class=&quot;com.wsj.controller.LoginController&quot;&gt;
            &lt;property name=&quot;username&quot;&gt;
                &lt;value&gt;admin&lt;/value&gt;
            &lt;/property&gt;
            &lt;property name=&quot;password&quot;&gt;
                &lt;value&gt;admin&lt;/value&gt;
            &lt;/property&gt;
        &lt;/bean&gt;

        &lt;!-- 路径和控制器的映射 --&gt;
        &lt;bean id=&quot;simpleUrlHandlerMapping&quot; class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;
            &lt;property name=&quot;mappings&quot;&gt;
                &lt;props&gt;
                    &lt;prop key=&quot;/login.do&quot;&gt;loginController&lt;/prop&gt;
                &lt;/props&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
&lt;/beans&gt;
</code></pre><p>##控制器</p>
<pre><code>package com.wsj.controller;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;

/**
 * 该示例下，一个controller只有一个方法
 * */
public class LoginController implements Controller{

    private String username;

    private String password;

    @Override
    public ModelAndView handleRequest(HttpServletRequest request,
            HttpServletResponse response) throws Exception {
        // TODO Auto-generated method stub
        String _username = request.getParameter(&quot;username&quot;);
        String _pwd =  request.getParameter(&quot;password&quot;);
        if(username.equals(_username) &amp;&amp; password.equals(_pwd)){
            return new ModelAndView(&quot;success&quot;);
        }
        return new ModelAndView(&quot;fail&quot;);
    }

    /**
    *getter、setter方法
    */
    ......

}
</code></pre><p>代码中的控制器实现<code>Controller</code>接口。当<code>login.do</code>的请求分发到该控制器时，默认执行<code>handleRequest</code>的方法。</p>
<p><code>return new ModelAndView(“success”)</code>表示跳转到<code>success.jsp</code>页面。</p>
<p>##视图与运行<br>本例子中的视图只有success.jsp和fail.jsp，分别表示登录成功和失败的页面。具体内容就不贴出来了。</p>
<p>在浏览器地址中输入<a href="localhost:8081/SpringMVC/login.do?username=admin&amp;password=admin" target="_blank" rel="external">localhost:8081/SpringMVC/login.do?username=admin&amp;password=admin</a>即可调用成功页面。</p>
<p>##能处理多方法的控制器<br>一个控制器只处理一个方法，感觉总有点奢侈浪费。Spring MVC是支持一个控制器处理多个方法的。</p>
<p>在WEB-INF/jsp里面创建一个名为multi的jsp页面：</p>
<pre><code>&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;ISO-8859-1&quot;%&gt;
&lt;%
String path = request.getContextPath();
String basePath = request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path+&quot;/&quot;;
%&gt;

&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt;

    &lt;title&gt;My JSP &apos;multi.jsp&apos; starting page&lt;/title&gt;

    &lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot;&gt;
    &lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt;
    &lt;meta http-equiv=&quot;expires&quot; content=&quot;0&quot;&gt;
    &lt;meta http-equiv=&quot;keywords&quot; content=&quot;keyword1,keyword2,keyword3&quot;&gt;
    &lt;meta http-equiv=&quot;description&quot; content=&quot;This is my page&quot;&gt;
    &lt;!--
    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styles.css&quot;&gt;
    --&gt;

  &lt;/head&gt;

  &lt;body&gt;
    &lt;h1&gt;请求的方法是：${method }&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>创建一个继承<code>MultiActionController</code>的控制器：</p>
<pre><code>package com.wsj.controller;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.multiaction.MultiActionController;

public class UserController extends MultiActionController {

    public ModelAndView add(HttpServletRequest request,
            HttpServletResponse response) {
        System.out.println(&quot;Add&quot;);
        return new ModelAndView(&quot;/multi&quot;, &quot;method&quot;, &quot;add&quot;);
    }

    public ModelAndView update(HttpServletRequest request,
            HttpServletResponse response) {
        System.out.println(&quot;Update&quot;);
        return new ModelAndView(&quot;/multi&quot;, &quot;method&quot;, &quot;update&quot;);
    }
}
</code></pre><p>代码中，两个方法都调用结束后都返回到<code>multi.jsp</code>页面，同时传一个参数名为<code>method</code>的参数，值分别为各自调用的方法名。</p>
<p>在<code>springmvc-servlet.xml</code>中添加如下配置：</p>
<pre><code>&lt;!-- 参数名称解析器，处理一个controller的多个方法。value=action，请求的时候指明action=&quot;目标方法&quot; --&gt;
&lt;bean id=&quot;paramMethodResolver&quot; class=&quot;org.springframework.web.servlet.mvc.multiaction.ParameterMethodNameResolver&quot;&gt;
    &lt;property name=&quot;paramName&quot; value=&quot;action&quot;/&gt;
&lt;/bean&gt;
&lt;!-- 控制器 --&gt;
&lt;bean id=&quot;userController&quot; class=&quot;com.wsj.controller.UserController&quot;&gt;
    &lt;property name=&quot;methodNameResolver&quot;&gt;
        &lt;ref bean=&quot;paramMethodResolver&quot;/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;!-- 路径和控制器的映射 --&gt;
&lt;bean id=&quot;simpleUrlHandlerMapping&quot; class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;
    &lt;property name=&quot;mappings&quot;&gt;
        &lt;props&gt;
            &lt;prop key=&quot;/login.do&quot;&gt;loginController&lt;/prop&gt;
            &lt;prop key=&quot;/user.do&quot;&gt;userController&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>参数名称解析器（ParameterMethodNameResolver）是Spring自带的，我们注入即可使用。这个解析器是靠我们配置的<code>paramName</code>的值<code>action</code>来解析请求的。</p>
<p>请求的时候，请使用<code>user.do?action=add</code>类似的来请求。</p>
<p><code>PS:</code></p>
<ol>
<li>用注解完成Spring MVC的笔记可以参考<a href="http://www.wonsikin.com/2014/06/19/spring-mvc注解小例子/" target="_blank" rel="external">下一篇博文</a><br>##参考</li>
<li><a href="http://elf8848.iteye.com/blog/875830/" target="_blank" rel="external">赵磊的博客</a></li>
<li><a href="http://liuzidong.iteye.com/blog/897047" target="_blank" rel="external">咫尺天涯</a></li>
<li><a href="http://www.blogbus.com/wanping-logs/235898608.html" target="_blank" rel="external">catherine的心路历程</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##简介&lt;br&gt;Spring自从创建以来，功能愈来愈丰富，从原本的依赖注入（DI）和面向切面编程（AOP）等简单功能发展成了具有MVC、ORM等功能的全能战士，大有一统江湖的态势。本文是个人的学习笔记，仅供参考。本人才疏学浅，如有谬误，还望指正，不胜感激涕零！&lt;br&gt;
    
    </summary>
    
    
      <category term="MVC" scheme="http://yoursite.com/tags/MVC/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="Java Web" scheme="http://yoursite.com/tags/Java-Web/"/>
    
  </entry>
  
  <entry>
    <title>Struts2通用文件下载示例</title>
    <link href="http://yoursite.com/2014/06/10/struts2%E9%80%9A%E7%94%A8%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E7%A4%BA%E4%BE%8B/"/>
    <id>http://yoursite.com/2014/06/10/struts2通用文件下载示例/</id>
    <published>2014-06-10T09:28:20.000Z</published>
    <updated>2016-03-28T12:58:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>#Struts2通用文件下载示例<br><a id="more"></a></p>
<p>###Action类</p>
<pre><code>public String download() {
    InputStream is = readDocsManager.getOneDoc(parent, name);
    HttpServletResponse response = HttpResponseHolder.getResponse();
    OutputStream out = null;
    try {
        //1.设置文件ContentType类型，这样设置，会自动判断下载文件类型  
        response.setContentType(&quot;multipart/form-data&quot;);  
        //2.设置文件头：最后一个参数是设置下载文件名
        response.setHeader(&quot;Content-Disposition&quot;, &quot;inline;fileName=&quot;+new String(name.getBytes(),&quot;ISO8859-1&quot;));
        out = response.getOutputStream();
        byte[] buf = new byte[1024];
        int size = -1;
        while ((size = is.read(buf)) != -1) {
            out.write(buf, 0, size);
        }
        response.flushBuffer();
    } catch (Exception e) {
        logger.error(e.getMessage(),e);
    }finally{
        IOUtils.closeQuietly(is);
        IOUtils.closeQuietly(out);

    }
    return &quot;download&quot;;
}
</code></pre><p>代码<code>readDocsManager.getOneDoc(parent,name)</code>是根据路径和名称读取文件，并返回一个<code>InputStream</code>的对象。</p>
<p>###struts.xml中的配置</p>
<pre><code>&lt;action name=&quot;docAction&quot; class=&quot;onlineDocsAction&quot;&gt;
    &lt;result name=&quot;download&quot; type=&quot;httpheader&quot;&gt;
    &lt;/result&gt;
&lt;/action&gt;
</code></pre><p>注意返回的类型是<code>httpheader</code>。</p>
<p>###中文转码问题</p>
<p>文件上传下载的时候，请一定要注意中文的转码，否则后台会报<code>FileNotFoundException</code>的错误。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#Struts2通用文件下载示例&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Struts2" scheme="http://yoursite.com/tags/Struts2/"/>
    
      <category term="File download" scheme="http://yoursite.com/tags/File-download/"/>
    
  </entry>
  
</feed>
